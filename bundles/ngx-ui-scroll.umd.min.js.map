{"version":3,"sources":["../../node_modules/tslib/tslib.es6.js","../package/src/component/utils/assignSettings.ts","../package/src/component/interfaces/direction.ts","../package/src/component/interfaces/process.ts","../package/src/component/classes/adapter.ts","../package/src/component/classes/datasource.ts","../package/src/component/classes/settings.ts","../package/src/component/classes/logger.ts","../package/src/component/classes/domRoutines.ts","../package/src/component/classes/paddings.ts","../package/src/component/classes/viewport.ts","../package/src/component/classes/cache.ts","../package/src/component/classes/buffer.ts","../package/src/component/classes/fetch.ts","../package/src/component/classes/state.ts","../package/src/component/scroller.ts","../package/src/component/utils/checkDatasource.ts","../package/src/component/processes/init.ts","../package/src/component/processes/scroll.ts","../package/src/component/processes/reload.ts","../package/src/component/processes/start.ts","../package/src/component/processes/preFetch.ts","../package/src/component/processes/fetch.ts","../package/src/component/classes/item.ts","../package/src/component/processes/postFetch.ts","../package/src/component/processes/render.ts","../package/src/component/processes/adjust.ts","../package/src/component/processes/clip.ts","../package/src/component/processes/end.ts","../package/src/component/workflow.ts","../package/src/ui-scroll.component.ts","../package/src/ui-scroll.directive.ts","../package/src/ui-scroll.version.ts","../package/src/ui-scroll.module.ts"],"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","assignBoolean","target","source","token","defaults","param","console","warn","assignNumeric","integer","parseInt","toString","assignMinimalNumeric","minSettings","mustExist","assignCommon","settings","getInitializedSubject","adapter","method","init","init$","pipe","switchMap","itemAdapterEmpty","data","element","Adapter","isInitialized","defineProperty","Observable","create","observer","intervalId","setInterval","clearInterval","next","complete","getVersion","getIsLoading","_this","getIsLoading$","getLoopPending","getLoopPending$","getCyclePending","getCyclePending$","getFirstVisible","getFirstVisible$","getLastVisible","getLastVisible$","getItemsCount","initialize","scroller","state","buffer","callWorkflow","version","isLoading","isLoadingSource","loopPending","loopPendingSource","workflowPending","workflowPendingSource","getVisibleItemsCount","initializeProtected","getFirstVisibleProtected","firstVisibleItem","firstVisibleWanted","getFirstVisible$Protected","firstVisibleSource","getLastVisibleProtected","lastVisibleItem","lastVisibleWanted","getLastVisible$Protected","lastVisibleSource","reload","reloadIndex","logger","log","process","Process","status","ProcessStatus","payload","showLog","logForce","setScrollPosition","value","Number","syntheticScroll","reset","viewport","setPosition","setMinIndex","index","isNaN","minIndexUser","Datasource","datasource","hasNoAdapter","constructed","observableOf","isLoading$","BehaviorSubject","cyclePending","cyclePending$","loopPending$","firstVisible","firstVisible$","lastVisible","lastVisible$","itemsCount","defaultSettings","startIndex","minIndex","Infinity","maxIndex","bufferSize","padding","infinite","horizontal","windowViewport","itemSize","defaultDevSettings","debug","immediateLog","logTime","throttle","inertia","inertiaScrollDelay","inertiaScrollDelta","initDelay","initWindowDelay","maxSynthScrollDelay","minDevSettings","Settings","devSettings","instanceIndex","assignSettings","assignDevSettings","initializeDelay","getInitializeDelay","result","history","Math","max","Logger","logs","getTime","time","getStat","first","getFirstVisibleItem","last","getLastVisibleItem","scrollPosition","getScrollableSize","paddings","backward","size","forward","hasItemSize","averageSize","$index","getFetchRange","_a","fetch","firstIndex","lastIndex","getInnerLoopCount","innerLoopCount","getWorkflowCycleData","more","workflowCycleCount","object","str","obj","stringify","JSON","replace","stat","logStyles_1","concat","_text_1","logStyles_2","logProcess","empty","processLog","styles","Status","workflowCycleData","loopCount","loopLog","keepScroll","byTimer","push","logData_1","logData_2","args","_i","Array","isArray","every","item","undefined","forEach","logArgs","Routines","getScrollPosition","getParams","tagName","toLowerCase","height","clientHeight","width","clientWidth","top","clientTop","bottom","left","clientLeft","right","getBoundingClientRect","getSize","getSizeStyle","style","setSizeStyle","getRectEdge","params","direction","opposite","Direction","getEdge","getEdge2","relativeElement","offsetTop","scrollTop","hideElement","display","getOffset","offsetLeft","Padding","routines","querySelector","round","Paddings","viewportSize","getPositiveSize","getNegativeSize","positiveSize","isFinite","negativeSize","Viewport","elementRef","nativeElement","host","body","scrollEventElement","scrollable","scrollRestoration","newPosition","bwdPaddingAverageSizeItemsCount","scrollState","startDelta","oldPosition","position","synthState","Date","now","delta","positionBefore","getBufferPadding","getElementEdge","ItemCache","nodeId","RecalculateAverage","newItems","oldItems","Cache","averageSizeFloat","items","Map","recalculateAverage","clear","recalculateAverageSize","oldItemsLength","newItemsLength","oldItemsSize","reduce","acc","getItemSize","newItemsSize","averageSizeLength","add","itemCache","get","set","Buffer","$items","cache","maxIndexUser","minBufferSize","hide","pristine","absMinIndex","absMaxIndex","_items","find","setItems","getFirstVisibleItemIndex","invisible","getLastVisibleItemIndex","getEdgeVisibleItem","getSizeByIndex","checkAverageSize","FetchModel","callCount","_newItemsData","firstIndexBuffer","lastIndexBuffer","hasAnotherPack","isPrepend","count","WindowScrollState","positionToUpdate","ScrollState","window","firstScroll","firstScrollTime","lastScrollTime","scrollTimer","workflowTimer","scroll","SyntheticScroll","readyToReset","State","initTime","isInitialLoop","isInitialWorkflowCycle","countDone","setCurrentStartIndex","clip","clipCall","sizeBeforeRender","fwdPaddingBeforeRender","getValue","startLoop","options","endLoop","newStartIndex","instanceCount","Scroller","context","Error","runChangeDetector","changeDetector","markForCheck","innerLoopSubscriptions","bindData","setTimeout","purgeInnerLoopSubscriptions","unsubscribe","purgeScrollTimers","localOnly","clearTimeout","dispose","finalize","Init","run","Scroll","processSyntheticScroll","delayScroll","synthetic","synthScrollDelay","inertiaDelta_1","syntheticDelta_1","newPosition_1","tDiff","dDiff","diff","doScroll","Reload","Start","PreFetch","preFetchPosition","averageItemSize","setStartDelta","setFetchIndexes","skipBufferedItems","checkFetchPackSize","setFetchDirection","shouldFetch","paddingDelta","relativePosition","startPosition","endPosition","firstIndexPosition","setFirstIndexBuffer","setLastIndexBuffer","inc","min","packs","pack","newLastIndex","newFirstIndex","direction_1","Fetch","subscribe","isError","fail","error","success","newItemsData","immediateData","immediateError","reject","_get","then","_observer","Item","String","setSize","PostFetch","setBufferLimits","hasNewItems","fetchIndex","map","Render","processElements","itemsLength","scrollBeforeRender","j","processWindowScrollBackJump","abs","Adjust","preAdjustPosition","setPaddingsResult","setPaddings","fixScrollPosition","firstItem","lastItem","forwardPadding","backwardPadding","hasAverageItemSizeChanged","bwdSize","fwdSize","fwdPaddingDiff","viewportSizeDiff","_b","posDiff_1","winState","setScroll","bwdAverageItemsCountDiff","positionDiff","MAX_SCROLL_ADJUSTMENTS_COUNT","Clip","prepareClip","doClip","prepareClipByDirection","edgeIndex","toRemove","removeDirection","clipped","filter","End","endWorkflowLoop","calculateParams","getNext","continueWorkflowByTimer","lastPosition","viewportBackwardEdge_1","viewportForwardEdge","Workflow","bind","process$","cyclesDone","onScrollHandler","event","initListeners","itemsSubscription","workflowSubscription","initScrollEventListener","passiveSupported","addEventListener","err","scrollEventOptions","passive","detachScrollEventListener","removeEventListener","done","processSubject","UiScrollComponent","ngOnInit","workflow","ngOnDestroy","Component","selector","changeDetection","ChangeDetectionStrategy","OnPush","template","ChangeDetectorRef","ElementRef","UiScrollDirective","templateRef","viewContainer","resolver","templateView","createEmbeddedView","compFactory","resolveComponentFactory","componentRef","createComponent","injector","rootNodes","instance","Directive","TemplateRef","ViewContainerRef","ComponentFactoryResolver","Input","UiScrollModule","NgModule","declarations","imports","CommonModule","entryComponents","exports","providers"],"mappings":"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","file":"ngx-ui-scroll.umd.min.js.map","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Settings as _ISettings, DevSettings as _IDevSettings } from '../interfaces/index';\r\nimport { Settings } from '../classes/settings';\r\n\r\ntype ISettings = _ISettings | _IDevSettings;\r\n\r\nconst assignBoolean = (\r\n  target: Settings, source: ISettings, token: string, defaults: ISettings\r\n) => {\r\n  const param = (<any>source)[token];\r\n  if (typeof param === 'undefined') {\r\n    return;\r\n  }\r\n  if (typeof param !== 'boolean') {\r\n    console.warn(token + ' setting parse error, set it to ' + (<any>defaults)[token] + ' (default)');\r\n    return;\r\n  }\r\n  (<any>target)[token] = param;\r\n  return true;\r\n};\r\n\r\nconst assignNumeric = (\r\n  target: Settings, source: ISettings, token: string, defaults: ISettings, integer = false\r\n) => {\r\n  const param = (<any>source)[token];\r\n  if (typeof param === 'undefined') {\r\n    return;\r\n  }\r\n  if (typeof param !== 'number') {\r\n    console.warn(token + ' setting parse error, set it to ' + (<any>defaults)[token] + ' (default)');\r\n    return;\r\n  }\r\n  if (integer && parseInt(param.toString(), 10) !== param) {\r\n    console.warn(token + ' setting parse error, set it to ' + (<any>defaults)[token] + ' (default)');\r\n    return;\r\n  }\r\n  (<any>target)[token] = param;\r\n  return true;\r\n};\r\n\r\nconst assignMinimalNumeric = (\r\n  target: Settings,\r\n  source: ISettings,\r\n  token: string,\r\n  defaults: ISettings,\r\n  minSettings: ISettings,\r\n  integer = false,\r\n  mustExist = true\r\n) => {\r\n  if (assignNumeric(target, source, token, defaults, integer) !== true) {\r\n    if (!mustExist) {\r\n      return;\r\n    }\r\n  }\r\n  if ((<any>target)[token] < (<any>minSettings)[token]) {\r\n    console.warn(token + ' setting is less than minimum, set it to ' + (<any>minSettings)[token]);\r\n    (<any>target)[token] = (<any>minSettings)[token];\r\n    return;\r\n  }\r\n  return true;\r\n};\r\n\r\nconst assignCommon = (target: Settings, settings: ISettings, defaults: ISettings) => {\r\n  Object.assign(target, defaults);\r\n  if (typeof settings === 'undefined') {\r\n    return;\r\n  }\r\n  if (typeof settings !== 'object') {\r\n    console.warn('settings is not an object, fallback to the defaults');\r\n    return;\r\n  }\r\n};\r\n\r\nexport const assignSettings = (\r\n  target: Settings, settings: _ISettings, defaults: _ISettings, minSettings: _ISettings\r\n) => {\r\n  assignCommon(target, settings, defaults);\r\n  assignBoolean(target, settings, 'adapter', defaults);\r\n  assignNumeric(target, settings, 'startIndex', defaults);\r\n  assignNumeric(target, settings, 'minIndex', defaults);\r\n  assignNumeric(target, settings, 'maxIndex', defaults);\r\n  assignMinimalNumeric(target, settings, 'itemSize', defaults, minSettings, true, false);\r\n  assignMinimalNumeric(target, settings, 'bufferSize', defaults, minSettings, true);\r\n  assignMinimalNumeric(target, settings, 'padding', defaults, minSettings);\r\n  assignBoolean(target, settings, 'infinite', defaults);\r\n  assignBoolean(target, settings, 'horizontal', defaults);\r\n  assignBoolean(target, settings, 'windowViewport', defaults);\r\n};\r\n\r\nexport const assignDevSettings = (\r\n  target: Settings, devSettings: _IDevSettings, defaults: _IDevSettings, minDevSettings: _IDevSettings\r\n) => {\r\n  assignCommon(target, devSettings, defaults);\r\n  assignBoolean(target, devSettings, 'debug', defaults);\r\n  assignBoolean(target, devSettings, 'immediateLog', defaults);\r\n  assignBoolean(target, devSettings, 'logTime', defaults);\r\n  assignMinimalNumeric(target, devSettings, 'throttle', defaults, minDevSettings, true);\r\n  assignBoolean(target, devSettings, 'inertia', defaults);\r\n  assignMinimalNumeric(target, devSettings, 'inertiaScrollDelay', defaults, minDevSettings, true);\r\n  assignMinimalNumeric(target, devSettings, 'inertiaScrollDelta', defaults, minDevSettings, true);\r\n  assignMinimalNumeric(target, devSettings, 'initDelay', defaults, minDevSettings, true);\r\n  assignMinimalNumeric(target, devSettings, 'initWindowDelay', defaults, minDevSettings, true);\r\n  assignMinimalNumeric(target, devSettings, 'maxSynthScrollDelay', defaults, minDevSettings, true);\r\n};\r\n","export enum Direction {\n  forward = 'forward',\n  backward = 'backward'\n}\n","export enum Process {\r\n  init = 'init',\r\n  scroll = 'scroll',\r\n  reload = 'reload',\r\n  start = 'start',\r\n  preFetch = 'preFetch',\r\n  fetch = 'fetch',\r\n  postFetch = 'postFetch',\r\n  render = 'render',\r\n  clip = 'clip',\r\n  adjust = 'adjust',\r\n  end = 'end'\r\n}\r\n\r\nexport enum ProcessStatus {\r\n  start = 'start',\r\n  next = 'next',\r\n  done = 'done',\r\n  error = 'error'\r\n}\r\n\r\nexport interface ScrollPayload {\r\n  event?: Event;\r\n  byTimer?: boolean;\r\n}\r\n\r\nexport interface ProcessRun {\r\n  empty?: boolean;\r\n  scroll?: boolean;\r\n  keepScroll?: boolean;\r\n  byTimer?: boolean;\r\n  error?: string;\r\n}\r\n\r\nexport interface ProcessSubject {\r\n  process: Process;\r\n  status: ProcessStatus;\r\n  payload?: ProcessRun;\r\n}\r\n\r\nexport type CallWorkflow = (processSubject: ProcessSubject) => undefined;\r\n","import { BehaviorSubject, Observable, Observer, of as observableOf } from 'rxjs';\r\nimport { switchMap } from 'rxjs/operators';\r\n\r\nimport { Adapter as IAdapter, Process, ProcessSubject, ProcessStatus, ItemAdapter } from '../interfaces/index';\r\nimport { Scroller } from '../scroller';\r\n\r\nconst getIsInitialized = (adapter: Adapter): Observable<boolean> =>\r\n  Observable.create((observer: Observer<boolean>) => {\r\n    const intervalId = setInterval(() => {\r\n      if (adapter && adapter.init) {\r\n        clearInterval(intervalId);\r\n        observer.next(true);\r\n        observer.complete();\r\n      }\r\n    }, 25);\r\n  });\r\n\r\nconst getInitializedSubject = (adapter: Adapter, method: Function): BehaviorSubject<any> => {\r\n  return adapter.init ? method() :\r\n    adapter.init$\r\n      .pipe(switchMap(() =>\r\n        method()\r\n      ));\r\n};\r\n\r\nexport const itemAdapterEmpty = <ItemAdapter> {\r\n  data: {},\r\n  element: {}\r\n};\r\n\r\nexport const generateMockAdapter = (): IAdapter => (\r\n  <IAdapter> {\r\n    version: null,\r\n    init: false,\r\n    init$: observableOf(false),\r\n    isLoading: false,\r\n    isLoading$: new BehaviorSubject<boolean>(false),\r\n    cyclePending: false,\r\n    cyclePending$: new BehaviorSubject<boolean>(false),\r\n    loopPending: false,\r\n    loopPending$: new BehaviorSubject<boolean>(false),\r\n    firstVisible: itemAdapterEmpty,\r\n    firstVisible$: new BehaviorSubject<ItemAdapter>(itemAdapterEmpty),\r\n    lastVisible: itemAdapterEmpty,\r\n    lastVisible$: new BehaviorSubject<ItemAdapter>(itemAdapterEmpty),\r\n    itemsCount: 0,\r\n    initialize: () => null,\r\n    reload: () => null,\r\n    showLog: () => null,\r\n    setMinIndex: () => null,\r\n    setScrollPosition: () => null\r\n  }\r\n);\r\n\r\nexport class Adapter implements IAdapter {\r\n\r\n  get init(): boolean {\r\n    return this.isInitialized;\r\n  }\r\n\r\n  get init$(): Observable<boolean> {\r\n    return getIsInitialized(this);\r\n  }\r\n\r\n  get version(): string | null {\r\n    return this.isInitialized ? this.getVersion() : null;\r\n  }\r\n\r\n  get isLoading(): boolean {\r\n    return this.isInitialized ? this.getIsLoading() : false;\r\n  }\r\n\r\n  get isLoading$(): BehaviorSubject<boolean> {\r\n    return getInitializedSubject(this, () => this.getIsLoading$());\r\n  }\r\n\r\n  get loopPending(): boolean {\r\n    return this.isInitialized ? this.getLoopPending() : false;\r\n  }\r\n\r\n  get loopPending$(): BehaviorSubject<boolean> {\r\n    return getInitializedSubject(this, () => this.getLoopPending$());\r\n  }\r\n\r\n  get cyclePending(): boolean {\r\n    return this.isInitialized ? this.getCyclePending() : false;\r\n  }\r\n\r\n  get cyclePending$(): BehaviorSubject<boolean> {\r\n    return getInitializedSubject(this, () => this.getCyclePending$());\r\n  }\r\n\r\n  get firstVisible(): ItemAdapter {\r\n    return this.isInitialized ? this.getFirstVisible() : {};\r\n  }\r\n\r\n  get firstVisible$(): BehaviorSubject<ItemAdapter> {\r\n    return getInitializedSubject(this, () => this.getFirstVisible$());\r\n  }\r\n\r\n  get lastVisible(): ItemAdapter {\r\n    return this.isInitialized ? this.getLastVisible() : {};\r\n  }\r\n\r\n  get lastVisible$(): BehaviorSubject<ItemAdapter> {\r\n    return getInitializedSubject(this, () => this.getLastVisible$());\r\n  }\r\n\r\n  get itemsCount(): number {\r\n    return this.isInitialized ? this.getItemsCount() : 0;\r\n  }\r\n\r\n  private scroller: Scroller;\r\n  private isInitialized: boolean;\r\n  private callWorkflow: Function;\r\n  private getVersion: Function;\r\n  private getIsLoading: Function;\r\n  private getIsLoading$: Function;\r\n  private getCyclePending: Function;\r\n  private getCyclePending$: Function;\r\n  private getLoopPending: Function;\r\n  private getLoopPending$: Function;\r\n  private getItemsCount: Function;\r\n  private getFirstVisible: Function;\r\n  private getFirstVisible$: Function;\r\n  private getLastVisible: Function;\r\n  private getLastVisible$: Function;\r\n\r\n  constructor() {\r\n    this.isInitialized = false;\r\n  }\r\n\r\n  initialize(scroller: Scroller) {\r\n    if (this.isInitialized) {\r\n      return;\r\n    }\r\n    this.scroller = scroller;\r\n    const { state, buffer } = scroller;\r\n    this.isInitialized = true;\r\n    this.callWorkflow = scroller.callWorkflow;\r\n    this.getVersion = (): string | null => scroller.version;\r\n    this.getIsLoading = (): boolean => state.isLoading;\r\n    this.getIsLoading$ = (): BehaviorSubject<boolean> => state.isLoadingSource;\r\n    this.getLoopPending = (): boolean => state.loopPending;\r\n    this.getLoopPending$ = (): BehaviorSubject<boolean> => state.loopPendingSource;\r\n    this.getCyclePending = (): boolean => state.workflowPending;\r\n    this.getCyclePending$ = (): BehaviorSubject<boolean> => state.workflowPendingSource;\r\n    this.getItemsCount = (): number => buffer.getVisibleItemsCount();\r\n    this.initializeProtected(scroller);\r\n  }\r\n\r\n  initializeProtected(scroller: Scroller) {\r\n    const { state } = scroller;\r\n    let getFirstVisibleProtected = () => {\r\n      getFirstVisibleProtected = () => state.firstVisibleItem;\r\n      state.firstVisibleWanted = true;\r\n      return state.firstVisibleItem;\r\n    };\r\n    let getFirstVisible$Protected = () => {\r\n      getFirstVisible$Protected = () => state.firstVisibleSource;\r\n      state.firstVisibleWanted = true;\r\n      return state.firstVisibleSource;\r\n    };\r\n    let getLastVisibleProtected = () => {\r\n      getLastVisibleProtected = () => state.lastVisibleItem;\r\n      state.lastVisibleWanted = true;\r\n      return state.lastVisibleItem;\r\n    };\r\n    let getLastVisible$Protected = () => {\r\n      getLastVisible$Protected = () => state.lastVisibleSource;\r\n      state.lastVisibleWanted = true;\r\n      return state.lastVisibleSource;\r\n    };\r\n    this.getFirstVisible = (): ItemAdapter => getFirstVisibleProtected();\r\n    this.getFirstVisible$ = (): BehaviorSubject<ItemAdapter> => getFirstVisible$Protected();\r\n    this.getLastVisible = (): ItemAdapter => getLastVisibleProtected();\r\n    this.getLastVisible$ = (): BehaviorSubject<ItemAdapter> => getLastVisible$Protected();\r\n  }\r\n\r\n  reload(reloadIndex?: number | string) {\r\n    this.scroller.logger.log(() => `adapter: reload(${reloadIndex})`);\r\n    this.callWorkflow(<ProcessSubject>{\r\n      process: Process.reload,\r\n      status: ProcessStatus.start,\r\n      payload: reloadIndex\r\n    });\r\n  }\r\n\r\n  showLog() {\r\n    this.scroller.logger.logForce();\r\n  }\r\n\r\n  setScrollPosition(value: number) {\r\n    this.scroller.logger.log(() => `adapter: setScrollPosition(${value})`);\r\n    const position = Number(value);\r\n    const parsedValue = parseInt(<any>value, 10);\r\n    if (position !== parsedValue) {\r\n      this.scroller.logger.log(() =>\r\n        `can't set scroll position because ${value} is not an integer`);\r\n    } else {\r\n      this.scroller.state.syntheticScroll.reset();\r\n      this.scroller.viewport.setPosition(value);\r\n    }\r\n  }\r\n\r\n  setMinIndex(value: number) {\r\n    this.scroller.logger.log(() => `adapter: setMinIndex(${value})`);\r\n    const index = Number(value);\r\n    if (isNaN(index)) {\r\n      this.scroller.logger.log(() =>\r\n        `can't set minIndex because ${value} is not a number`);\r\n    } else {\r\n      this.scroller.buffer.minIndexUser = index;\r\n    }\r\n  }\r\n}\r\n","import {\r\n  Datasource as IDatasource, DatasourceGet, DevSettings, Settings, Adapter as IAdapter\r\n} from '../interfaces/index';\r\nimport { Adapter, generateMockAdapter } from './adapter';\r\n\r\nexport class Datasource implements IDatasource {\r\n  readonly constructed: boolean;\r\n  get: DatasourceGet;\r\n  settings?: Settings;\r\n  devSettings?: DevSettings;\r\n  adapter: IAdapter;\r\n\r\n  constructor(datasource: IDatasource, hasNoAdapter?: boolean) {\r\n    this.constructed = true;\r\n    Object.assign(<any>this, datasource);\r\n    if (hasNoAdapter) {\r\n      this.adapter = <IAdapter>generateMockAdapter();\r\n    } else {\r\n      this.adapter = new Adapter();\r\n    }\r\n  }\r\n}\r\n","import { Settings as ISettings, DevSettings as IDevSettings } from '../interfaces/index';\nimport { assignSettings, assignDevSettings } from '../utils/index';\n\nexport const defaultSettings: ISettings = {\n  adapter: false,\n  startIndex: 1,\n  minIndex: -Infinity,\n  maxIndex: Infinity,\n  bufferSize: 5,\n  padding: 0.5,\n  infinite: false,\n  horizontal: false,\n  windowViewport: false\n};\n\nexport const minSettings: ISettings = {\n  itemSize: 1,\n  bufferSize: 1,\n  padding: 0.01\n};\n\nexport const defaultDevSettings: IDevSettings = {\n  debug: false, // if true, logging is enabled; need to turn off when release\n  immediateLog: true, // if false, logging is not immediate and could be done via Workflow.logForce call\n  logTime: false, // if true, time differences are being logged\n  throttle: 40, // if > 0, scroll event handling is throttled (ms)\n  inertia: false, // if true, inertia scroll delay (ms) and delta (px) are taken into the account\n  inertiaScrollDelay: 125,\n  inertiaScrollDelta: 35,\n  initDelay: 1, // if set, the Workflow initialization will be postponed (ms)\n  initWindowDelay: 40, // if set and the entire window is scrollable, the Workflow init will be postponed (ms)\n  maxSynthScrollDelay: 450 // if > 0, synthetic scroll params will be reset after [value] (ms)\n};\n\nexport const minDevSettings: IDevSettings = {\n  throttle: 0,\n  inertiaScrollDelay: 0,\n  inertiaScrollDelta: 0,\n  initDelay: 0,\n  initWindowDelay: 0,\n  maxSynthScrollDelay: 0\n};\n\nexport class Settings implements ISettings {\n\n  // user settings\n  adapter: boolean;\n  startIndex: number;\n  minIndex: number;\n  maxIndex: number;\n  itemSize: number;\n  bufferSize: number;\n  padding: number;\n  infinite: boolean;\n  horizontal: boolean;\n  windowViewport: boolean;\n\n  // development settings\n  debug: boolean;\n  immediateLog: boolean;\n  logTime: boolean;\n  throttle: number;\n  inertia: boolean;\n  inertiaScrollDelay: number;\n  inertiaScrollDelta: number;\n  initDelay: number;\n  initWindowDelay: number;\n  maxSynthScrollDelay: number;\n\n  // internal settings, managed by scroller itself\n  instanceIndex: number;\n  initializeDelay: number;\n\n  constructor(\n    settings: ISettings | undefined, devSettings: IDevSettings | undefined, instanceIndex: number\n  ) {\n    assignSettings(this, settings || {}, defaultSettings, minSettings);\n    assignDevSettings(this, devSettings || {}, defaultDevSettings, minDevSettings);\n    this.instanceIndex = instanceIndex;\n    this.initializeDelay = this.getInitializeDelay();\n    // todo: min/max indexes must be ignored if infinite mode is enabled ??\n  }\n\n  getInitializeDelay(): number {\n    let result = 0;\n    if (this.windowViewport && this.initWindowDelay && !('scrollRestoration' in history)) {\n      result = this.initWindowDelay;\n    }\n    if (this.initDelay > 0) {\n      result = Math.max(result, this.initDelay);\n    }\n    return result;\n  }\n}\n","import { Scroller } from '../scroller';\nimport { Process, ProcessRun, ProcessStatus as Status, ProcessSubject } from '../interfaces/index';\n\nexport class Logger {\n\n  readonly debug: boolean;\n  readonly immediateLog: boolean;\n  readonly logTime: boolean;\n  readonly getTime: Function;\n  readonly getStat: Function;\n  readonly getFetchRange: Function;\n  readonly getInnerLoopCount: Function;\n  readonly getWorkflowCycleData: Function;\n  private logs: Array<any> = [];\n\n  constructor(scroller: Scroller) {\n    const { settings } = scroller;\n    this.debug = settings.debug;\n    this.immediateLog = settings.immediateLog;\n    this.logTime = settings.logTime;\n    this.getTime = (): string =>\n      scroller.state && ` // time: ${scroller.state.time}`;\n    this.getStat = (): string => {\n      const { buffer, viewport } = scroller;\n      const first = buffer.getFirstVisibleItem();\n      const last = buffer.getLastVisibleItem();\n      return 'pos: ' + viewport.scrollPosition + ', ' +\n        'size: ' + viewport.getScrollableSize() + ', ' +\n        'bwd_p: ' + viewport.paddings.backward.size + ', ' +\n        'fwd_p: ' + viewport.paddings.forward.size + ', ' +\n        'aver: ' + (buffer.hasItemSize ? buffer.averageSize : 'no') + ', ' +\n        'items: ' + buffer.getVisibleItemsCount() + ', ' +\n        'range: ' + (first && last ? `[${first.$index}..${last.$index}]` : 'no');\n    };\n    this.getFetchRange = (): string => {\n      const { firstIndex, lastIndex } = scroller.state.fetch;\n      const hasInterval = firstIndex !== null && lastIndex !== null && !isNaN(firstIndex) && !isNaN(lastIndex);\n      return hasInterval ? `[${firstIndex}..${lastIndex}]` : 'no';\n    };\n    this.getInnerLoopCount = (): number => scroller.state.innerLoopCount;\n    this.getWorkflowCycleData = (more: boolean): string =>\n      `${scroller.settings.instanceIndex}-${scroller.state.workflowCycleCount}` + (more ? '-' : '');\n    this.log(() => `uiScroll Workflow has been started (v${scroller.version}, instance ${settings.instanceIndex})`);\n  }\n\n  object(str: string, obj: any, stringify?: boolean) {\n    this.log(() => [\n      str,\n      stringify\n        ? JSON.stringify(obj)\n          .replace(/\"/g, '')\n          .replace(/(\\{|\\:|\\,)/g, '$1 ')\n        : obj\n    ]);\n  }\n\n  stat(str?: string) {\n    if (this.debug) {\n      const logStyles = ['color: #888; border: dashed #888 0; border-bottom-width: 0px', 'color: #000; border-width: 0'];\n      this.log(() => ['%cstat' + (str ? ` ${str}` : '') + ',%c ' + this.getStat(), ...logStyles]);\n    }\n  }\n\n  fetch(str?: string) {\n    if (this.debug) {\n      const _text = 'fetch interval' + (str ? ` ${str}` : '');\n      const logStyles = ['color: #888', 'color: #000'];\n      this.log(() => [`%c${_text}: %c${this.getFetchRange()}`, ...logStyles]);\n    }\n  }\n\n  logProcess(data: ProcessSubject) {\n    if (!this.debug) {\n      return;\n    }\n    const { process, status } = data;\n    const payload: ProcessRun = data.payload || { empty: true };\n\n    // standard process log\n    const processLog = `process ${process}, %c${status}%c` + (!payload.empty ? ',' : '');\n    const styles = [status === Status.error ? 'color: #cc0000;' : '', 'color: #000000;'];\n    this.log(() => [processLog, ...styles, ...(!payload.empty ? [payload] : [])]);\n\n    // inner loop start-end log\n    const workflowCycleData = this.getWorkflowCycleData(true);\n    const loopCount = this.getInnerLoopCount();\n    const loopLog: string[] = [];\n    if (\n      process === Process.init && status === Status.next ||\n      process === Process.scroll && status === Status.next && payload.keepScroll ||\n      process === Process.end && status === Status.next && payload.byTimer\n    ) {\n      loopLog.push(`%c---=== loop ${workflowCycleData + (loopCount + 1)} start`);\n    } else if (\n      process === Process.end && !payload.byTimer\n    ) {\n      loopLog.push(`%c---=== loop ${workflowCycleData + loopCount} done`);\n      if (status === Status.next && !(payload.keepScroll)) {\n        loopLog[0] += `, loop ${workflowCycleData + (loopCount + 1)} start`;\n      }\n    }\n    if (loopLog.length) {\n      this.log(() => [...loopLog, 'color: #006600;']);\n    }\n\n    // workflow cycle start log\n    if (\n      process === Process.init && status === Status.start ||\n      process === Process.reload && status === Status.next ||\n      process === Process.scroll && status === Status.next && !(payload.keepScroll)\n    ) {\n      const logData = this.getWorkflowCycleData(false);\n      const logStyles = 'color: #0000aa; border: solid black 1px; border-width: 1px 0 0 1px; margin-left: -2px';\n      this.log(() => [`%c   ~~~ WF Cycle ${logData} STARTED ~~~  `, logStyles]);\n    }\n\n    // workflow run end log\n    if (process === Process.end && status === Status.done) {\n      const logData = this.getWorkflowCycleData(false);\n      const logStyles = 'color: #0000aa; border: solid #555 1px; border-width: 0 0 1px 1px; margin-left: -2px';\n      this.log(() => [`%c   ~~~ WF Cycle ${logData} FINALIZED ~~~  `, logStyles]);\n    }\n  }\n\n  log(...args: Array<any>) {\n    if (this.debug) {\n      if (typeof args[0] === 'function') {\n        args = args[0]();\n        if (!Array.isArray(args)) {\n          args = [args];\n        }\n      }\n      if (args.every(item => item === undefined)) {\n        return;\n      }\n      if (this.logTime) {\n        args = [...args, this.getTime()];\n      }\n      if (this.immediateLog) {\n        console.log.apply(this, args);\n      } else {\n        this.logs.push(args);\n      }\n    }\n  }\n\n  logForce(...args: Array<any>) {\n    if (this.debug) {\n      if (!this.immediateLog && this.logs.length) {\n        this.logs.forEach(logArgs => console.log.apply(this, logArgs));\n        this.logs = [];\n      }\n      if (args.length) {\n        console.log.apply(this, args);\n      }\n    }\n  }\n}\n","import { Direction } from '../interfaces/direction';\nimport { Settings } from './settings';\n\nexport class Routines {\n\n  readonly horizontal: boolean;\n\n  constructor(settings: Settings) {\n    this.horizontal = settings.horizontal;\n  }\n\n  getScrollPosition(element: HTMLElement): number {\n    return element[this.horizontal ? 'scrollLeft' : 'scrollTop'];\n  }\n\n  setScrollPosition(element: HTMLElement, value: number) {\n    element[this.horizontal ? 'scrollLeft' : 'scrollTop'] = value;\n  }\n\n  getParams(element: HTMLElement): ClientRect {\n    if (element.tagName.toLowerCase() === 'body') {\n      element = <HTMLElement>element.parentElement;\n      return <ClientRect>{\n        'height': element.clientHeight,\n        'width': element.clientWidth,\n        'top': element.clientTop,\n        'bottom': element.clientTop + element.clientHeight,\n        'left': element.clientLeft,\n        'right': element.clientLeft + element.clientWidth\n      };\n    }\n    return element.getBoundingClientRect();\n  }\n\n  getSize(element: HTMLElement): number {\n    return this.getParams(element)[this.horizontal ? 'width' : 'height'];\n  }\n\n  getSizeStyle(element: HTMLElement): number {\n    const size = element.style[this.horizontal ? 'width' : 'height'];\n    return parseInt(<string>size, 10) || 0;\n  }\n\n  setSizeStyle(element: HTMLElement, value: number) {\n    element.style[this.horizontal ? 'width' : 'height'] = `${value}px`;\n  }\n\n  getRectEdge(params: ClientRect, direction: Direction, opposite?: boolean): number {\n    const forward = !opposite ? Direction.forward : Direction.backward;\n    return params[direction === forward ? (this.horizontal ? 'right' : 'bottom') : (this.horizontal ? 'left' : 'top')];\n  }\n\n  getEdge(element: HTMLElement, direction: Direction, opposite?: boolean): number {\n    const params = this.getParams(element);\n    return this.getRectEdge(params, direction, opposite);\n  }\n\n  getEdge2(element: HTMLElement, direction: Direction, relativeElement: HTMLElement, opposite: boolean): number {\n    // vertical only ?\n    return element.offsetTop - (relativeElement ? relativeElement.scrollTop : 0) +\n      (direction === (!opposite ? Direction.forward : Direction.backward) ? this.getSize(element) : 0);\n  }\n\n  hideElement(element: HTMLElement) {\n    element.style.display = 'none';\n  }\n\n  getOffset(element: HTMLElement): number {\n    return this.horizontal ? element.offsetLeft : element.offsetTop;\n  }\n\n}\n","import { Direction } from '../interfaces/direction';\r\nimport { Routines } from './domRoutines';\r\nimport { Settings } from './settings';\r\n\r\nexport class Padding {\r\n\r\n  element: HTMLElement;\r\n  direction: Direction;\r\n  routines: Routines;\r\n\r\n  constructor(element: HTMLElement, direction: Direction, routines: Routines) {\r\n    this.element = <HTMLElement>element.querySelector(`[data-padding-${direction}]`);\r\n    this.direction = direction;\r\n    this.routines = routines;\r\n  }\r\n\r\n  reset(size?: number) {\r\n    this.size = size || 0;\r\n  }\r\n\r\n  get size(): number {\r\n    return this.routines.getSizeStyle(this.element);\r\n  }\r\n\r\n  set size(value: number) {\r\n    this.routines.setSizeStyle(this.element, Math.round(value));\r\n  }\r\n\r\n}\r\n\r\nexport class Paddings {\r\n  settings: Settings;\r\n  forward: Padding;\r\n  backward: Padding;\r\n\r\n  constructor(element: HTMLElement, routines: Routines, settings: Settings) {\r\n    this.settings = settings;\r\n    this.forward = new Padding(element, Direction.forward, routines);\r\n    this.backward = new Padding(element, Direction.backward, routines);\r\n  }\r\n\r\n  reset(viewportSize: number, startIndex: number) {\r\n    this.forward.reset(this.getPositiveSize(startIndex, viewportSize));\r\n    this.backward.reset(this.getNegativeSize(startIndex));\r\n  }\r\n\r\n  getPositiveSize(startIndex: number, viewportSize: number) {\r\n    const { settings } = this;\r\n    let positiveSize = viewportSize;\r\n    if (isFinite(settings.maxIndex)) {\r\n      positiveSize = (settings.maxIndex - startIndex + 1) * settings.itemSize;\r\n    }\r\n    return positiveSize;\r\n  }\r\n\r\n  getNegativeSize(startIndex: number) {\r\n    const { settings } = this;\r\n    let negativeSize = 0;\r\n    if (isFinite(settings.minIndex)) {\r\n      negativeSize = (startIndex - settings.minIndex) * settings.itemSize;\r\n    }\r\n    return negativeSize;\r\n  }\r\n}\r\n","import { ElementRef } from '@angular/core';\n\nimport { Direction } from '../interfaces/index';\nimport { Paddings } from './paddings';\nimport { Settings } from './settings';\nimport { Routines } from './domRoutines';\nimport { State } from './state';\nimport { Logger } from './logger';\n\nexport class Viewport {\n\n  paddings: Paddings;\n  startDelta: number;\n\n  readonly element: HTMLElement;\n  readonly host: HTMLElement;\n  readonly scrollEventElement: HTMLElement | Document;\n  readonly scrollable: HTMLElement;\n  readonly settings: Settings;\n  readonly routines: Routines;\n  readonly state: State;\n  readonly logger: Logger;\n\n  constructor(elementRef: ElementRef, settings: Settings, routines: Routines, state: State, logger: Logger) {\n    this.settings = settings;\n    this.routines = routines;\n    this.state = state;\n    this.logger = logger;\n    this.element = elementRef.nativeElement;\n\n    if (settings.windowViewport) {\n      this.host = (<Document>this.element.ownerDocument).body;\n      this.scrollEventElement = <Document>(this.element.ownerDocument);\n      this.scrollable = <HTMLElement>this.scrollEventElement.scrollingElement;\n    } else {\n      this.host = <HTMLElement>this.element.parentElement;\n      this.scrollEventElement = this.host;\n      this.scrollable = <HTMLElement>this.element.parentElement;\n    }\n\n    this.paddings = new Paddings(this.element, this.routines, settings);\n\n    if (settings.windowViewport && 'scrollRestoration' in history) {\n      history.scrollRestoration = 'manual';\n    }\n  }\n\n  reset(scrollPosition: number) {\n    let newPosition = 0;\n    this.paddings.reset(this.getSize(), this.state.startIndex);\n    const negativeSize = this.paddings.backward.size;\n    if (negativeSize) {\n      newPosition = negativeSize;\n      this.state.bwdPaddingAverageSizeItemsCount = negativeSize / this.settings.itemSize;\n    }\n    this.scrollPosition = newPosition;\n    this.state.scrollState.reset();\n    this.state.syntheticScroll.reset(scrollPosition !== newPosition ? newPosition : null);\n    this.startDelta = 0;\n  }\n\n  setPosition(value: number, oldPosition?: number): number {\n    if (oldPosition === undefined) {\n      oldPosition = this.scrollPosition;\n    }\n    if (oldPosition === value) {\n      this.logger.log(() => ['setting scroll position at', value, '[cancelled]']);\n      return value;\n    }\n    this.routines.setScrollPosition(this.scrollable, value);\n    const position = this.scrollPosition;\n    this.logger.log(() => ['setting scroll position at', position]);\n    return position;\n  }\n\n  get scrollPosition(): number {\n    return this.routines.getScrollPosition(this.scrollable);\n  }\n\n  set scrollPosition(value: number) {\n    const oldPosition = this.scrollPosition;\n    const newPosition = this.setPosition(value, oldPosition);\n    const synthState = this.state.syntheticScroll;\n    synthState.time = Number(Date.now());\n    synthState.position = newPosition;\n    synthState.delta = newPosition - oldPosition;\n    if (synthState.positionBefore === null) {\n      // syntheticScroll.positionBefore should be set once per cycle\n      synthState.positionBefore = oldPosition;\n    }\n  }\n\n  getSize(): number {\n    return this.routines.getSize(this.host);\n  }\n\n  getScrollableSize(): number {\n    return this.routines.getSize(this.element);\n  }\n\n  getBufferPadding(): number {\n    return this.getSize() * this.settings.padding;\n  }\n\n  getEdge(direction: Direction, opposite?: boolean): number {\n    return this.routines.getEdge(this.host, direction, opposite);\n  }\n\n  getElementEdge(element: HTMLElement, direction: Direction, opposite?: boolean): number {\n    return this.routines.getEdge(element, direction, opposite);\n  }\n\n  getOffset(): number {\n    return this.routines.getOffset(this.element);\n  }\n\n}\n","import { Item } from './item';\nimport { Settings } from '../classes/settings';\nimport { Logger } from './logger';\n\nexport class ItemCache {\n  $index: number;\n  nodeId: string;\n  data: any; // todo: cache data only if it is permitted by settings\n  size: number;\n  position: number;\n\n  constructor(item: Item) {\n    this.$index = item.$index;\n    this.nodeId = item.nodeId;\n    this.data = item.data;\n    this.size = item.size;\n  }\n}\n\nexport class RecalculateAverage {\n  newItems: Array<number>;\n  oldItems: Array<number>;\n\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    this.newItems = [];\n    this.oldItems = [];\n  }\n}\n\nexport class Cache {\n  averageSizeFloat: number;\n  averageSize: number;\n  minIndex: number;\n  maxIndex: number;\n  recalculateAverage: RecalculateAverage;\n\n  private items: Map<number, ItemCache>;\n  readonly logger: Logger;\n  readonly itemSize: number;\n\n  constructor(itemSize: number, logger: Logger) {\n    this.averageSizeFloat = itemSize;\n    this.averageSize = itemSize;\n    this.itemSize = itemSize;\n    this.items = new Map<number, ItemCache>();\n    this.recalculateAverage = new RecalculateAverage();\n    this.reset();\n    this.logger = logger;\n  }\n\n  reset() {\n    this.minIndex = +Infinity;\n    this.maxIndex = -Infinity;\n    this.items.clear();\n    this.averageSizeFloat = this.itemSize;\n    this.averageSize = this.itemSize;\n    this.recalculateAverage.reset();\n  }\n\n  recalculateAverageSize() {\n    const { oldItems: { length: oldItemsLength }, newItems: { length: newItemsLength } } = this.recalculateAverage;\n    if (!oldItemsLength && !newItemsLength) {\n      return;\n    }\n    const oldItemsSize = this.recalculateAverage.oldItems.reduce((acc, index) => acc + this.getItemSize(index), 0);\n    const newItemsSize = this.recalculateAverage.newItems.reduce((acc, index) => acc + this.getItemSize(index), 0);\n    if (oldItemsLength) {\n      const averageSize = this.averageSizeFloat || 0;\n      const averageSizeLength = this.items.size - newItemsLength - oldItemsLength;\n      this.averageSizeFloat = (averageSizeLength * averageSize + oldItemsSize) / averageSizeLength;\n    }\n    if (newItemsLength) {\n      const averageSize = this.averageSizeFloat || 0;\n      const averageSizeLength = this.items.size - newItemsLength;\n      this.averageSizeFloat = (averageSizeLength * averageSize + newItemsSize) / this.items.size;\n    }\n    this.averageSize = Math.round(this.averageSizeFloat);\n    this.recalculateAverage.reset();\n    this.logger.log(() => `average size has been updated: ${this.averageSize}`);\n  }\n\n  add(item: Item): ItemCache {\n    let itemCache = this.get(item.$index);\n    if (itemCache) {\n      itemCache.data = item.data;\n      if (itemCache.size !== item.size) {\n        itemCache.size = item.size;\n        this.recalculateAverage.oldItems.push(item.$index);\n      }\n    } else {\n      itemCache = new ItemCache(item);\n      this.items.set(item.$index, itemCache);\n      if (this.averageSize !== itemCache.size) {\n        this.recalculateAverage.newItems.push(item.$index);\n      }\n    }\n    if (item.$index < this.minIndex) {\n      this.minIndex = item.$index;\n    }\n    if (item.$index > this.maxIndex) {\n      this.maxIndex = item.$index;\n    }\n    return itemCache;\n  }\n\n  getItemSize(index: number): number {\n    const item = this.get(index);\n    return item ? item.size : 0;\n  }\n\n  get(index: number): ItemCache | undefined {\n    return this.items.get(index);\n  }\n}\n","import { BehaviorSubject } from 'rxjs';\n\nimport { Direction } from '../interfaces/index';\nimport { Cache } from './cache';\nimport { Item } from './item';\nimport { Settings } from './settings';\nimport { Logger } from './logger';\n\nexport class Buffer {\n\n  private _items: Array<Item>;\n  $items: BehaviorSubject<Array<Item>>;\n\n  pristine: boolean;\n  cache: Cache;\n  minIndexUser: number;\n  maxIndexUser: number;\n  absMinIndex: number;\n  absMaxIndex: number;\n\n  private startIndex: number;\n  readonly minBufferSize: number;\n  readonly logger: Logger;\n\n  constructor(settings: Settings, startIndex: number, logger: Logger) {\n    this.$items = new BehaviorSubject<Array<Item>>([]);\n    this.cache = new Cache(settings.itemSize, logger);\n    this.minIndexUser = settings.minIndex;\n    this.maxIndexUser = settings.maxIndex;\n    this.reset();\n    this.startIndex = startIndex;\n    this.minBufferSize = settings.bufferSize;\n    this.logger = logger;\n  }\n\n  reset(reload?: boolean, startIndex?: number) {\n    if (reload) {\n      this.items.forEach(item => item.hide());\n    }\n    this.items = [];\n    this.pristine = true;\n    this.cache.reset();\n    this.absMinIndex = this.minIndexUser;\n    this.absMaxIndex = this.maxIndexUser;\n    if (typeof startIndex !== 'undefined') {\n      this.startIndex = startIndex;\n    }\n  }\n\n  set items(items: Array<Item>) {\n    this.pristine = false;\n    this._items = items;\n    this.$items.next(items);\n  }\n\n  get items(): Array<Item> {\n    return this._items;\n  }\n\n  get size(): number {\n    return this._items.length;\n  }\n\n  get averageSize(): number {\n    return this.cache.averageSize;\n  }\n\n  get hasItemSize(): boolean {\n    return this.averageSize !== undefined;\n  }\n\n  get minIndex(): number {\n    return isFinite(this.cache.minIndex) ? this.cache.minIndex : this.startIndex;\n  }\n\n  get maxIndex(): number {\n    return isFinite(this.cache.maxIndex) ? this.cache.maxIndex : this.startIndex;\n  }\n\n  get bof(): boolean {\n    return this.items.length ? (this.items[0].$index === this.absMinIndex) :\n      isFinite(this.absMinIndex);\n  }\n\n  get eof(): boolean {\n    return this.items.length ? (this.items[this.items.length - 1].$index === this.absMaxIndex) :\n      isFinite(this.absMaxIndex);\n  }\n\n  get($index: number): Item | undefined {\n    return this.items.find((item: Item) => item.$index === $index);\n  }\n\n  setItems(items: Array<Item>): boolean {\n    if (!this.items.length) {\n      this.items = items;\n    } else if (this.items[0].$index > items[items.length - 1].$index) {\n      this.items = [...items, ...this.items];\n    } else if (items[0].$index > this.items[this.items.length - 1].$index) {\n      this.items = [...this.items, ...items];\n    } else {\n      return false;\n    }\n    return true;\n  }\n\n  getFirstVisibleItemIndex(): number {\n    const length = this.items.length;\n    for (let i = 0; i < length; i++) {\n      if (!this.items[i].invisible) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  getLastVisibleItemIndex(): number {\n    for (let i = this.items.length - 1; i >= 0; i--) {\n      if (!this.items[i].invisible) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  getFirstVisibleItem(): Item | undefined {\n    const index = this.getFirstVisibleItemIndex();\n    if (index >= 0) {\n      return this.items[index];\n    }\n  }\n\n  getLastVisibleItem(): Item | undefined {\n    const index = this.getLastVisibleItemIndex();\n    if (index >= 0) {\n      return this.items[index];\n    }\n  }\n\n  getEdgeVisibleItem(direction: Direction, opposite?: boolean): Item | undefined {\n    return direction === (!opposite ? Direction.forward : Direction.backward) ?\n      this.getLastVisibleItem() : this.getFirstVisibleItem();\n  }\n\n  getVisibleItemsCount(): number {\n    return this.items.reduce((acc: number, item: Item) => acc + (item.invisible ? 0 : 1), 0);\n  }\n\n  getSizeByIndex(index: number): number {\n    const item = this.cache.get(index);\n    return item ? item.size : this.averageSize;\n  }\n\n  checkAverageSize() {\n    this.cache.recalculateAverageSize();\n  }\n\n}\n","import { Item } from './item';\nimport { Direction } from '../interfaces/index';\n\nexport class FetchModel {\n  private _newItemsData: Array<any> | null;\n  items: Array<Item>;\n  firstIndexBuffer: number | null;\n  lastIndexBuffer: number | null;\n  firstIndex: number | null;\n  lastIndex: number | null;\n  hasAnotherPack: boolean;\n  callCount: number;\n  minIndex: number;\n  negativeSize: number;\n  averageItemSize: number;\n  direction: Direction | null;\n  isPrepend: boolean;\n\n  constructor() {\n    this.callCount = 0;\n    this.reset();\n  }\n\n  reset() {\n    this._newItemsData = null;\n    this.items = [];\n    this.firstIndexBuffer = null;\n    this.lastIndexBuffer = null;\n    this.firstIndex = null;\n    this.lastIndex = null;\n    this.hasAnotherPack = false;\n    this.negativeSize = 0;\n    this.direction = null;\n    this.isPrepend = false;\n  }\n\n  get newItemsData(): Array<Item> | null {\n    return this._newItemsData;\n  }\n\n  set newItemsData(items: Array<Item> | null) {\n    this._newItemsData = items;\n    this.callCount++;\n  }\n\n  get shouldFetch(): boolean {\n    return !!this.count;\n  }\n\n  get hasNewItems(): boolean {\n    return !!((this._newItemsData && this._newItemsData.length));\n  }\n\n  get index(): number | null {\n    return this.firstIndex;\n  }\n\n  get count(): number {\n    return this.firstIndex !== null && this.lastIndex !== null ? this.lastIndex - this.firstIndex + 1 : 0;\n  }\n}\n","import { BehaviorSubject } from 'rxjs';\r\n\r\nimport {\r\n  State as IState,\r\n  ProcessRun,\r\n  ItemAdapter,\r\n  WindowScrollState as IWindowScrollState,\r\n  ScrollState as IScrollState,\r\n  SyntheticScroll as ISyntheticScroll\r\n} from '../interfaces/index';\r\nimport { FetchModel } from './fetch';\r\nimport { Settings } from './settings';\r\nimport { Logger } from './logger';\r\nimport { itemAdapterEmpty } from './adapter';\r\n\r\nclass WindowScrollState implements IWindowScrollState {\r\n  positionToUpdate: number;\r\n  delta: number;\r\n\r\n  constructor() {\r\n    this.reset();\r\n  }\r\n\r\n  reset() {\r\n    this.delta = 0;\r\n    this.positionToUpdate = 0;\r\n  }\r\n}\r\n\r\nclass ScrollState implements IScrollState {\r\n  firstScroll: boolean;\r\n  firstScrollTime: number;\r\n  lastScrollTime: number;\r\n  scrollTimer: number | null;\r\n  workflowTimer: number | null;\r\n  scroll: boolean;\r\n  keepScroll: boolean;\r\n  window: IWindowScrollState;\r\n\r\n  constructor() {\r\n    this.window = new WindowScrollState();\r\n    this.reset();\r\n  }\r\n\r\n  reset() {\r\n    this.firstScroll = false;\r\n    this.firstScrollTime = 0;\r\n    this.lastScrollTime = 0;\r\n    this.scrollTimer = null;\r\n    this.workflowTimer = null;\r\n    this.scroll = false;\r\n    this.keepScroll = false;\r\n    this.window.reset();\r\n  }\r\n}\r\n\r\nclass SyntheticScroll implements ISyntheticScroll {\r\n  position: number | null;\r\n  positionBefore: number | null;\r\n  delta: number;\r\n  time: number;\r\n  readyToReset: boolean;\r\n\r\n  constructor() {\r\n    this.reset(null);\r\n  }\r\n\r\n  reset(position: number | null = null) {\r\n    this.position = position;\r\n    this.positionBefore = null;\r\n    this.delta = 0;\r\n    this.time = 0;\r\n    this.readyToReset = false;\r\n  }\r\n}\r\n\r\nexport class State implements IState {\r\n\r\n  protected settings: Settings;\r\n  protected logger: Logger;\r\n\r\n  initTime: number;\r\n  innerLoopCount: number;\r\n  isInitialLoop: boolean;\r\n  workflowCycleCount: number;\r\n  isInitialWorkflowCycle: boolean;\r\n  countDone: number;\r\n\r\n  startIndex: number;\r\n  fetch: FetchModel;\r\n  clip: boolean;\r\n  clipCall: number;\r\n  lastPosition: number;\r\n  preFetchPosition: number;\r\n  preAdjustPosition: number;\r\n  sizeBeforeRender: number;\r\n  fwdPaddingBeforeRender: number;\r\n  bwdPaddingAverageSizeItemsCount: number;\r\n\r\n  scrollState: IScrollState;\r\n  syntheticScroll: ISyntheticScroll;\r\n\r\n  loopPendingSource: BehaviorSubject<boolean>;\r\n  workflowPendingSource: BehaviorSubject<boolean>;\r\n  isLoadingSource: BehaviorSubject<boolean>;\r\n  firstVisibleSource: BehaviorSubject<ItemAdapter>;\r\n  lastVisibleSource: BehaviorSubject<ItemAdapter>;\r\n  firstVisibleWanted: boolean;\r\n  lastVisibleWanted: boolean;\r\n\r\n  get loopPending(): boolean {\r\n    return this.loopPendingSource.getValue();\r\n  }\r\n\r\n  set loopPending(value: boolean) {\r\n    if (this.loopPending !== value) {\r\n      this.loopPendingSource.next(value);\r\n    }\r\n  }\r\n\r\n  get workflowPending(): boolean {\r\n    return this.workflowPendingSource.getValue();\r\n  }\r\n\r\n  set workflowPending(value: boolean) {\r\n    if (this.workflowPending !== value) {\r\n      this.workflowPendingSource.next(value);\r\n    }\r\n  }\r\n\r\n  get isLoading(): boolean {\r\n    return this.isLoadingSource.getValue();\r\n  }\r\n\r\n  set isLoading(value: boolean) {\r\n    if (this.isLoading !== value) {\r\n      this.isLoadingSource.next(value);\r\n    }\r\n  }\r\n\r\n  get firstVisibleItem(): ItemAdapter {\r\n    return this.firstVisibleSource.getValue();\r\n  }\r\n\r\n  set firstVisibleItem(item: ItemAdapter) {\r\n    if (this.firstVisibleItem.$index !== item.$index) {\r\n      this.firstVisibleSource.next(item);\r\n    }\r\n  }\r\n\r\n  get lastVisibleItem(): ItemAdapter {\r\n    return this.lastVisibleSource.getValue();\r\n  }\r\n\r\n  set lastVisibleItem(item: ItemAdapter) {\r\n    if (this.lastVisibleItem.$index !== item.$index) {\r\n      this.lastVisibleSource.next(item);\r\n    }\r\n  }\r\n\r\n  get time(): number {\r\n    return Number(new Date()) - this.initTime;\r\n  }\r\n\r\n  constructor(settings: Settings, logger: Logger) {\r\n    this.settings = settings;\r\n    this.logger = logger;\r\n    this.initTime = Number(new Date());\r\n    this.innerLoopCount = 0;\r\n    this.isInitialLoop = false;\r\n    this.workflowCycleCount = 1;\r\n    this.isInitialWorkflowCycle = false;\r\n    this.countDone = 0;\r\n\r\n    this.setCurrentStartIndex(settings.startIndex);\r\n    this.fetch = new FetchModel();\r\n    this.clip = false;\r\n    this.clipCall = 0;\r\n    this.sizeBeforeRender = 0;\r\n    this.fwdPaddingBeforeRender = 0;\r\n    this.bwdPaddingAverageSizeItemsCount = 0;\r\n\r\n    this.scrollState = new ScrollState();\r\n    this.syntheticScroll = new SyntheticScroll();\r\n\r\n    this.loopPendingSource = new BehaviorSubject<boolean>(false);\r\n    this.workflowPendingSource = new BehaviorSubject<boolean>(false);\r\n    this.isLoadingSource = new BehaviorSubject<boolean>(false);\r\n    this.firstVisibleSource = new BehaviorSubject<ItemAdapter>(itemAdapterEmpty);\r\n    this.lastVisibleSource = new BehaviorSubject<ItemAdapter>(itemAdapterEmpty);\r\n    this.firstVisibleWanted = false;\r\n    this.lastVisibleWanted = false;\r\n  }\r\n\r\n  startLoop(options?: ProcessRun) {\r\n    this.loopPending = true;\r\n    this.innerLoopCount++;\r\n    this.fetch.reset();\r\n    this.clip = false;\r\n    if (options) {\r\n      this.scrollState.scroll = options.scroll || false;\r\n    }\r\n    this.scrollState.keepScroll = false;\r\n  }\r\n\r\n  endLoop() {\r\n    this.loopPending = false;\r\n    this.countDone++;\r\n    this.isInitialLoop = false;\r\n  }\r\n\r\n  setCurrentStartIndex(newStartIndex: any) {\r\n    const { startIndex, minIndex, maxIndex } = this.settings;\r\n    let index = Number(newStartIndex);\r\n    if (isNaN(index)) {\r\n      this.logger.log(() =>\r\n        `fallback startIndex to settings.startIndex (${startIndex}) because ${newStartIndex} is not a number`);\r\n      index = startIndex;\r\n    }\r\n    if (index < minIndex) {\r\n      this.logger.log(() => `setting startIndex to settings.minIndex (${minIndex}) because ${index} < ${minIndex}`);\r\n      index = minIndex;\r\n    }\r\n    if (index > maxIndex) {\r\n      this.logger.log(() => `setting startIndex to settings.maxIndex (${maxIndex}) because ${index} > ${maxIndex}`);\r\n      index = maxIndex;\r\n    }\r\n    this.startIndex = index;\r\n  }\r\n\r\n}\r\n","import { Observable, Subscription, Observer } from 'rxjs';\n\nimport { UiScrollComponent } from '../ui-scroll.component';\nimport { checkDatasource } from './utils/index';\nimport { Datasource } from './classes/datasource';\nimport { Settings } from './classes/settings';\nimport { Logger } from './classes/logger';\nimport { Routines } from './classes/domRoutines';\nimport { Viewport } from './classes/viewport';\nimport { Buffer } from './classes/buffer';\nimport { State } from './classes/state';\nimport { CallWorkflow } from './interfaces/index';\n\nlet instanceCount = 0;\n\nexport class Scroller {\n\n  readonly runChangeDetector: Function;\n  readonly callWorkflow: CallWorkflow;\n\n  public version: string;\n  public datasource: Datasource;\n  public settings: Settings;\n  public logger: Logger;\n  public routines: Routines;\n  public viewport: Viewport;\n  public buffer: Buffer;\n  public state: State;\n\n  public innerLoopSubscriptions: Array<Subscription>;\n\n  constructor(context: UiScrollComponent, callWorkflow: CallWorkflow) {\n    const datasource = <Datasource>checkDatasource(context.datasource);\n    this.datasource = datasource;\n    this.version = context.version;\n\n    this.runChangeDetector = () => context.changeDetector.markForCheck();\n    // this.runChangeDetector = () => context.changeDetector.detectChanges();\n    this.callWorkflow = callWorkflow;\n    this.innerLoopSubscriptions = [];\n\n    this.settings = new Settings(datasource.settings, datasource.devSettings, ++instanceCount);\n    this.logger = new Logger(this);\n    this.routines = new Routines(this.settings);\n    this.state = new State(this.settings, this.logger);\n    this.buffer = new Buffer(this.settings, this.state.startIndex, this.logger);\n    this.viewport = new Viewport(context.elementRef, this.settings, this.routines, this.state, this.logger);\n\n    this.logger.object('uiScroll settings object', this.settings, true);\n\n    if (!datasource.constructed) {\n      this.datasource = new Datasource(datasource, !this.settings.adapter);\n      if (this.settings.adapter) {\n        this.datasource.adapter.initialize(this);\n      }\n    } else {\n      this.datasource.adapter.initialize(this);\n    }\n  }\n\n  init() {\n    this.viewport.reset(0);\n  }\n\n  bindData(): Observable<any> {\n    this.runChangeDetector();\n    return Observable.create((observer: Observer<any>) => {\n        setTimeout(() => {\n          observer.next(true);\n          observer.complete();\n        });\n      }\n    );\n  }\n\n  purgeInnerLoopSubscriptions() {\n    this.innerLoopSubscriptions.forEach((item: Subscription) => item.unsubscribe());\n    this.innerLoopSubscriptions = [];\n  }\n\n  purgeScrollTimers(localOnly?: boolean) {\n    const { state: { scrollState } } = this;\n    if (scrollState.scrollTimer) {\n      clearTimeout(scrollState.scrollTimer);\n      scrollState.scrollTimer = null;\n    }\n    if (!localOnly && scrollState.workflowTimer) {\n      clearTimeout(scrollState.workflowTimer);\n      scrollState.workflowTimer = null;\n    }\n  }\n\n  dispose() {\n    this.purgeInnerLoopSubscriptions();\n    this.purgeScrollTimers();\n  }\n\n  finalize() {\n  }\n\n}\n","import { Datasource as IDatasource } from '../interfaces/index';\n\nexport const checkDatasource = (datasource: IDatasource) => {\n  if (!datasource) {\n    throw new Error('No datasource provided');\n  }\n  if (!('get' in datasource)) {\n    throw new Error('Datasource get method is not implemented');\n  }\n  if (typeof datasource.get !== 'function') {\n    throw new Error('Datasource get is not a function');\n  }\n  if ((<Function>(datasource.get)).length < 2) {\n    throw new Error('Datasource get method invalid signature');\n  }\n  return datasource;\n};\n","import { Scroller } from '../scroller';\nimport { Process, ProcessStatus, ProcessRun } from '../interfaces/index';\n\nexport default class Init {\n\n  static run(scroller: Scroller, payload?: ProcessRun) {\n    scroller.state.isInitialWorkflowCycle = !payload;\n    scroller.state.isInitialLoop = !payload;\n    scroller.state.workflowPending = true;\n    scroller.state.isLoading = true;\n    scroller.callWorkflow({\n      process: Process.init,\n      status: ProcessStatus.next,\n      payload: {\n        scroll: payload && payload.scroll || false\n      }\n    });\n  }\n\n}\n","import { Scroller } from '../scroller';\nimport { Process, ProcessStatus, ScrollPayload } from '../interfaces/index';\n\nexport default class Scroll {\n\n  static run(scroller: Scroller, payload: ScrollPayload = {}) {\n    scroller.logger.log(scroller.viewport.scrollPosition);\n    if (scroller.state.syntheticScroll.position !== null) {\n      if (!Scroll.processSyntheticScroll(scroller)) {\n        return;\n      }\n    }\n    this.delayScroll(scroller, payload);\n  }\n\n  static processSyntheticScroll(scroller: Scroller): boolean {\n    const { viewport, state: { syntheticScroll }, settings, logger } = scroller;\n    const time = Number(new Date());\n    const synthetic = { ...syntheticScroll };\n    const position = viewport.scrollPosition;\n    const synthScrollDelay = time - synthetic.time;\n\n    if (synthScrollDelay > settings.maxSynthScrollDelay) {\n      logger.log(() => `reset synthetic scroll params (${synthScrollDelay} > ${settings.maxSynthScrollDelay})`);\n      syntheticScroll.reset();\n      return position !== synthetic.position;\n    }\n\n    // synthetic scroll\n    syntheticScroll.readyToReset = true;\n    if (position === synthetic.position) {\n      // let's reset syntheticScroll.position on first change\n      logger.log(() => `skip synthetic scroll (${position})`);\n      return false;\n    } else if (synthetic.readyToReset) {\n      syntheticScroll.position = null;\n      syntheticScroll.positionBefore = null;\n      logger.log(() => 'reset synthetic scroll params');\n    }\n    if (settings.windowViewport) {\n      if (!synthetic.readyToReset) {\n        logger.log(() => 'reset synthetic scroll params (window)');\n        syntheticScroll.reset();\n      }\n      return true;\n    }\n\n    // inertia scroll over synthetic scroll\n    if (position !== synthetic.position) {\n      const inertiaDelta = <number>synthetic.positionBefore - position;\n      const syntheticDelta = <number>synthetic.position - position;\n      if (inertiaDelta > 0 && inertiaDelta < syntheticDelta) {\n        const newPosition = Math.max(0, position + syntheticScroll.delta);\n        logger.log(() => 'inertia scroll adjustment' +\n          '. Position: ' + position +\n          ', synthetic position: ' + synthetic.position +\n          ', synthetic position before: ' + synthetic.positionBefore +\n          ', synthetic delay: ' + synthScrollDelay +\n          ', synthetic delta: ' + syntheticDelta +\n          ', inertia delta: ' + inertiaDelta +\n          ', new position: ' + newPosition);\n        if (settings.inertia) { // precise inertia settings\n          if (inertiaDelta <= settings.inertiaScrollDelta && synthScrollDelay <= settings.inertiaScrollDelay) {\n            viewport.scrollPosition = newPosition;\n          }\n        } else {\n          viewport.scrollPosition = newPosition;\n        }\n      } /* else {\n        logger.log(() => 'inertia scroll adjustment [cancelled]' +\n          '. Position: ' + position +\n          ', synthetic position: ' + synthetic.position +\n          ', synthetic position before: ' + synthetic.positionBefore +\n          ', synthetic delta: ' + syntheticDelta + ', inertia delta: ' + inertiaDelta);\n      } */\n    }\n    return true;\n  }\n\n  static delayScroll(scroller: Scroller, payload: ScrollPayload) {\n    if (!scroller.settings.throttle || payload.byTimer) {\n      Scroll.doScroll(scroller);\n      return;\n    }\n    const { state: { scrollState } } = scroller;\n    const time = Number(Date.now());\n    const tDiff = scrollState.lastScrollTime + scroller.settings.throttle - time;\n    const dDiff = scroller.settings.throttle + (scrollState.firstScrollTime ? scrollState.firstScrollTime - time : 0);\n    const diff = Math.max(tDiff, dDiff);\n    // scroller.logger.log('tDiff:', tDiff, 'dDiff:', dDiff, 'diff:', diff);\n    if (diff <= 0) {\n      scroller.purgeScrollTimers(true);\n      scrollState.lastScrollTime = time;\n      scrollState.firstScrollTime = 0;\n      Scroll.doScroll(scroller);\n    } else if (!scrollState.scrollTimer && !scrollState.keepScroll) {\n      scroller.logger.log(() => `setting the timer at ${scroller.state.time + diff}`);\n      scrollState.firstScrollTime = time;\n      scrollState.scrollTimer = <any>setTimeout(() => {\n        scrollState.scrollTimer = null;\n        scroller.logger.log(() => `fire the timer (${scroller.state.time})`);\n        Scroll.run(scroller, { byTimer: true });\n      }, diff);\n    } /* else {\n      scroller.logger.log('MISS TIMER');\n    } */\n  }\n\n  static doScroll(scroller: Scroller) {\n    const { state, state: { scrollState } } = scroller;\n    if (state.workflowPending) {\n      scroller.logger.log(() =>\n        !scrollState.keepScroll ? [\n          `setting %ckeepScroll%c flag (scrolling while the Workflow is pending)`,\n          'color: #006600;', 'color: #000000;'\n        ] : undefined);\n      scrollState.keepScroll = true;\n      return;\n    }\n    scroller.callWorkflow({\n      process: Process.scroll,\n      status: ProcessStatus.next,\n      payload: {\n        scroll: true,\n        ...(scrollState.keepScroll ? { keepScroll: scrollState.keepScroll } : {})\n      }\n    });\n  }\n\n}\n","import { Scroller } from '../scroller';\nimport { Process, ProcessStatus } from '../interfaces/index';\n\nexport default class Reload {\n\n  static run(scroller: Scroller, reloadIndex: any) {\n    const scrollPosition = scroller.viewport.scrollPosition;\n    scroller.state.setCurrentStartIndex(reloadIndex);\n    scroller.buffer.reset(true, scroller.state.startIndex);\n    scroller.viewport.reset(scrollPosition);\n    scroller.purgeInnerLoopSubscriptions();\n    scroller.purgeScrollTimers();\n    // todo: do we need to have Process.end before?\n    scroller.callWorkflow({\n      process: Process.reload,\n      status: ProcessStatus.next\n    });\n  }\n\n}\n","import { Scroller } from '../scroller';\nimport { Process, ProcessRun, ProcessStatus } from '../interfaces/index';\n\nexport default class Start {\n\n  static run(scroller: Scroller, payload?: ProcessRun) {\n    scroller.state.startLoop(payload);\n    scroller.callWorkflow({\n      process: Process.start,\n      status: ProcessStatus.next\n    });\n  }\n\n}\n","import { Scroller } from '../scroller';\nimport { Process, ProcessStatus, Direction } from '../interfaces/index';\n\nexport default class PreFetch {\n\n  static run(scroller: Scroller) {\n    const { fetch } = scroller.state;\n    scroller.state.preFetchPosition = scroller.viewport.scrollPosition;\n    fetch.minIndex = scroller.buffer.minIndex;\n    fetch.averageItemSize = scroller.buffer.averageSize || 0;\n\n    // calculate size before start index\n    PreFetch.setStartDelta(scroller);\n\n    // set first and last indexes to fetch\n    PreFetch.setFetchIndexes(scroller);\n\n    // skip indexes that are in buffer\n    PreFetch.skipBufferedItems(scroller);\n\n    // add indexes if there are too few items to fetch (clip padding)\n    PreFetch.checkFetchPackSize(scroller);\n\n    // set fetch direction\n    PreFetch.setFetchDirection(scroller);\n\n    if (fetch.shouldFetch) {\n      scroller.logger.log(() => `going to fetch ${fetch.count} items started from index ${fetch.index}`);\n    }\n\n    scroller.callWorkflow({\n      process: Process.preFetch,\n      status: scroller.state.fetch.shouldFetch ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n  static setStartDelta(scroller: Scroller) {\n    const { buffer, viewport } = scroller;\n    viewport.startDelta = 0;\n    if (!buffer.hasItemSize) {\n      return;\n    }\n    const minIndex = isFinite(buffer.absMinIndex) ? buffer.absMinIndex : buffer.minIndex;\n    for (let index = minIndex; index < scroller.state.startIndex; index++) {\n      const item = buffer.cache.get(index);\n      viewport.startDelta += item ? item.size : buffer.averageSize;\n    }\n    if (scroller.settings.windowViewport) {\n      viewport.startDelta += viewport.getOffset();\n    }\n    scroller.logger.log(() => `start delta is ${viewport.startDelta}`);\n  }\n\n  static setFetchIndexes(scroller: Scroller) {\n    const { state, viewport } = scroller;\n    const paddingDelta = viewport.getBufferPadding();\n    const relativePosition = state.preFetchPosition - viewport.startDelta;\n    const startPosition = relativePosition - paddingDelta;\n    const endPosition = relativePosition + viewport.getSize() + paddingDelta;\n    const firstIndexPosition =\n      PreFetch.setFirstIndexBuffer(scroller, startPosition);\n    PreFetch.setLastIndexBuffer(scroller, firstIndexPosition, endPosition);\n    scroller.logger.fetch();\n  }\n\n  static setFirstIndexBuffer(scroller: Scroller, startPosition: number): number {\n    const { state, buffer, state: { fetch } } = scroller;\n    let firstIndex = state.startIndex;\n    let firstIndexPosition = 0;\n    if (scroller.state.isInitialLoop) {\n      scroller.logger.log(`skipping fetch backward direction [initial loop]`);\n    } else {\n      const inc = startPosition < 0 ? -1 : 1;\n      let position = firstIndexPosition;\n      let index = firstIndex;\n      while (1) {\n        index += inc;\n        if (index < buffer.absMinIndex) {\n          break;\n        }\n        position += inc * buffer.getSizeByIndex(index);\n        if (inc < 0) {\n          firstIndex = index;\n          firstIndexPosition = position;\n          if (position <= startPosition) {\n            break;\n          }\n        } else {\n          if (position > startPosition) {\n            break;\n          }\n          firstIndex = index;\n          firstIndexPosition = position;\n        }\n      }\n    }\n    fetch.firstIndex = fetch.firstIndexBuffer = Math.max(firstIndex, buffer.absMinIndex);\n    return firstIndexPosition;\n  }\n\n  static setLastIndexBuffer(scroller: Scroller, startPosition: number, endPosition: number) {\n    const { state, buffer, settings } = scroller;\n    let lastIndex;\n    if (!buffer.hasItemSize) {\n      // just to fetch forward bufferSize items if neither averageItemSize nor itemSize are present\n      lastIndex = state.startIndex + settings.bufferSize - 1;\n      scroller.logger.log(`forcing fetch forward direction [no item size]`);\n    } else {\n      let index = <number>state.fetch.firstIndexBuffer;\n      let position = startPosition;\n      let lastIndexPosition;\n      lastIndex = index;\n      while (1) {\n        lastIndex = index;\n        index++;\n        position += buffer.getSizeByIndex(index);\n        lastIndexPosition = position;\n        if (position >= endPosition) {\n          break;\n        }\n        if (index > buffer.absMaxIndex) {\n          break;\n        }\n      }\n    }\n    state.fetch.lastIndex = state.fetch.lastIndexBuffer = Math.min(lastIndex, buffer.absMaxIndex);\n  }\n\n  static skipBufferedItems(scroller: Scroller) {\n    const buffer = scroller.buffer;\n    if (!buffer.size) {\n      return;\n    }\n    const { fetch } = scroller.state;\n    const firstIndex = <number>fetch.firstIndex;\n    const lastIndex = <number>fetch.lastIndex;\n    const packs: Array<Array<number>> = [[]];\n    let p = 0;\n    for (let i = firstIndex; i <= lastIndex; i++) {\n      if (!buffer.get(i)) {\n        packs[p].push(i);\n      } else if (packs[p].length) {\n        packs[++p] = [];\n      }\n    }\n    let pack = packs[0];\n    if (packs[0].length && packs[1] && packs[1].length) {\n      fetch.hasAnotherPack = true;\n      // todo: need to look for biggest pack in visible area\n      // todo: or think about merging two requests in a single Fetch process\n      if (packs[1].length >= packs[0].length) {\n        pack = packs[1];\n      }\n    }\n    fetch.firstIndex = Math.max(pack[0], buffer.absMinIndex);\n    fetch.lastIndex = Math.min(pack[pack.length - 1], buffer.absMaxIndex);\n    if (fetch.firstIndex !== firstIndex || fetch.lastIndex !== lastIndex) {\n      scroller.logger.fetch('after Buffer flushing');\n    }\n  }\n\n  static checkFetchPackSize(scroller: Scroller) {\n    const { buffer, state: { fetch } } = scroller;\n    if (!fetch.shouldFetch) {\n      return;\n    }\n    const firstIndex = <number>fetch.firstIndex;\n    const lastIndex = <number>fetch.lastIndex;\n    const diff = scroller.settings.bufferSize - (lastIndex - firstIndex + 1);\n    if (diff <= 0) {\n      return;\n    }\n    if (!buffer.size || lastIndex > buffer.items[0].$index) { // forward\n      const newLastIndex = Math.min(lastIndex + diff, buffer.absMaxIndex);\n      if (newLastIndex > lastIndex) {\n        fetch.lastIndex = fetch.lastIndexBuffer = newLastIndex;\n      }\n    } else {\n      const newFirstIndex = Math.max(firstIndex - diff, buffer.absMinIndex);\n      if (newFirstIndex < firstIndex) {\n        fetch.firstIndex = fetch.firstIndexBuffer = newFirstIndex;\n      }\n    }\n    if (fetch.firstIndex !== firstIndex || fetch.lastIndex !== lastIndex) {\n      scroller.logger.fetch('after bufferSize adjustment');\n      PreFetch.skipBufferedItems(scroller);\n    }\n  }\n\n  static setFetchDirection(scroller: Scroller) {\n    const { buffer, state: { fetch } } = scroller;\n    if (fetch.lastIndex) {\n      let direction = Direction.forward;\n      if (buffer.size) {\n        direction = fetch.lastIndex < buffer.items[0].$index ? Direction.backward : Direction.forward;\n      }\n      fetch.direction = direction;\n      scroller.logger.log(() => `fetch direction is \"${direction}\"`);\n    }\n  }\n\n}\n","import { Observable, Observer } from 'rxjs';\n\nimport { Scroller } from '../scroller';\nimport { Process, ProcessStatus } from '../interfaces/index';\n\nexport default class Fetch {\n\n  static run(scroller: Scroller) {\n    const result = Fetch.get(scroller);\n    if (typeof result.subscribe !== 'function') {\n      if (!result.isError) {\n        Fetch.success(result.data, scroller);\n      } else {\n        Fetch.fail(result.error, scroller);\n      }\n    } else {\n      scroller.innerLoopSubscriptions.push(\n        result.subscribe(\n          (data: Array<any>) => Fetch.success(data, scroller),\n          (error: any) => Fetch.fail(error, scroller)\n        )\n      );\n    }\n  }\n\n  static success(data: Array<any>, scroller: Scroller) {\n    scroller.logger.log(() => `resolved ${data.length} items ` +\n      `(index = ${scroller.state.fetch.index}, count = ${scroller.state.fetch.count})`);\n    scroller.state.fetch.newItemsData = data;\n\n    scroller.callWorkflow({\n      process: Process.fetch,\n      status: ProcessStatus.next\n    });\n  }\n\n  static fail(error: string, scroller: Scroller) {\n    scroller.callWorkflow({\n      process: Process.fetch,\n      status: ProcessStatus.error,\n      payload: { error }\n    });\n  }\n\n  static get(scroller: Scroller) {\n    const _get = <Function>scroller.datasource.get;\n\n    let immediateData, immediateError;\n    let observer: Observer<any>;\n    const success = (data: any) => {\n      if (!observer) {\n        immediateData = data || null;\n        return;\n      }\n      observer.next(data);\n      observer.complete();\n    };\n    const reject = (error: any) => {\n      if (!observer) {\n        immediateError = error || null;\n        return;\n      }\n      observer.error(error);\n    };\n\n    const result = _get(scroller.state.fetch.index, scroller.state.fetch.count, success, reject);\n    if (result && typeof result.then === 'function') { // DatasourceGetPromise\n      result.then(success, reject);\n    } else if (result && typeof result.subscribe === 'function') { // DatasourceGetObservable\n      return result; // do not wrap observable\n    }\n\n    if (immediateData !== undefined || immediateError !== undefined) {\n      return {\n        data: immediateData,\n        error: immediateError,\n        isError: immediateError !== undefined\n      };\n    }\n\n    return Observable.create((_observer: Observer<any>) => {\n      observer = _observer;\n    });\n  }\n\n}\n","import { Routines } from './domRoutines';\nimport { Direction } from '../interfaces/index';\n\nexport class Item {\n  $index: number;\n  data: any;\n  nodeId: string;\n  routines: Routines;\n\n  element: HTMLElement;\n  size: number;\n  invisible: boolean;\n  toRemove: boolean;\n  removeDirection: Direction;\n\n  constructor($index: number, data: any, routines: Routines) {\n    this.$index = $index;\n    this.data = data;\n    this.nodeId = String($index);\n    this.routines = routines;\n    this.invisible = true;\n  }\n\n  setSize() {\n    this.size = this.routines.getSize(this.element);\n  }\n\n  hide() {\n    if (this.element) {\n      this.routines.hideElement(this.element);\n    }\n  }\n}\n","import { Scroller } from '../scroller';\nimport { Item } from '../classes/item';\nimport { Process, ProcessStatus } from '../interfaces/index';\n\nexport default class PostFetch {\n\n  static run(scroller: Scroller) {\n    if (PostFetch.setItems(scroller)) {\n      PostFetch.setBufferLimits(scroller);\n      scroller.callWorkflow({\n        process: Process.postFetch,\n        status: scroller.state.fetch.hasNewItems ? ProcessStatus.next : ProcessStatus.done\n      });\n    } else {\n      scroller.callWorkflow({\n        process: Process.postFetch,\n        status: ProcessStatus.error,\n        payload: { error: 'Can\\'t set buffer items' }\n      });\n    }\n  }\n\n  static setBufferLimits(scroller: Scroller) {\n    const { buffer, state: { fetch: { firstIndex, lastIndex, items } } } = scroller;\n    if (!items.length) {\n      if (<number>lastIndex < buffer.minIndex) {\n        buffer.absMinIndex = buffer.minIndex;\n      }\n      if (<number>firstIndex > buffer.maxIndex) {\n        buffer.absMaxIndex = buffer.maxIndex;\n      }\n    } else {\n      const last = items.length - 1;\n      if (<number>firstIndex < items[0].$index) {\n        buffer.absMinIndex = items[0].$index;\n      }\n      if (<number>lastIndex > items[last].$index) {\n        buffer.absMaxIndex = items[last].$index;\n      }\n    }\n  }\n\n  static setItems(scroller: Scroller): boolean {\n    const { buffer, state: { fetch } } = scroller;\n    const items = fetch.newItemsData;\n    if (!items || !items.length) { // empty result\n      return true;\n    }\n    // eof/bof case, need to shift fetch index if bof\n    let fetchIndex = <number>fetch.index;\n    if (items.length < fetch.count) {\n      if (scroller.state.isInitialLoop) {\n        // let's treat initial poor fetch as startIndex-bof\n        fetchIndex = scroller.state.startIndex;\n      } else if (<number>fetch.firstIndex < buffer.minIndex) { // normal bof\n        fetchIndex = buffer.minIndex - items.length;\n      }\n    }\n    fetch.items = items.map((item, index: number) =>\n      new Item(fetchIndex + index, item, scroller.routines)\n    );\n    fetch.isPrepend = !!buffer.items.length && buffer.items[0].$index > fetch.items[fetch.items.length - 1].$index;\n    return buffer.setItems(fetch.items);\n  }\n\n}\n","import { Scroller } from '../scroller';\nimport { Process, ProcessStatus } from '../interfaces/index';\n\nexport default class Render {\n\n  static run(scroller: Scroller) {\n    scroller.logger.stat('before new items render');\n    scroller.innerLoopSubscriptions.push(\n      scroller.bindData().subscribe(() => {\n        if (Render.processElements(scroller)) {\n          scroller.callWorkflow({\n            process: Process.render,\n            status: ProcessStatus.next\n          });\n        } else {\n          scroller.callWorkflow({\n            process: Process.render,\n            status: ProcessStatus.error,\n            payload: { error: 'Can\\'t associate item with element' }\n          });\n        }\n      })\n    );\n  }\n\n  static processElements(scroller: Scroller) {\n    const { state, state: { fetch, fetch: { items } }, viewport, buffer } = scroller;\n    const itemsLength = items.length;\n    const scrollBeforeRender = scroller.settings.windowViewport ? scroller.viewport.scrollPosition : 0;\n    state.sizeBeforeRender = viewport.getScrollableSize();\n    state.fwdPaddingBeforeRender = viewport.paddings.forward.size;\n    for (let j = 0; j < itemsLength; j++) {\n      const item = items[j];\n      const element = viewport.element.querySelector(`[data-sid=\"${item.nodeId}\"]`);\n      if (!element) {\n        return false;\n      }\n      item.element = <HTMLElement>element;\n      item.element.style.left = '';\n      item.element.style.position = '';\n      item.invisible = false;\n      item.setSize();\n      buffer.cache.add(item);\n      if (item.$index < fetch.minIndex) {\n        fetch.negativeSize += item.size;\n      }\n    }\n    buffer.checkAverageSize();\n    if (scroller.settings.windowViewport && fetch.isPrepend) {\n      Render.processWindowScrollBackJump(scroller, scrollBeforeRender);\n    }\n    scroller.logger.stat('after new items render');\n    return true;\n  }\n\n  static processWindowScrollBackJump(scroller: Scroller, scrollBeforeRender: number) {\n    const { state, state: { scrollState: { window } }, viewport } = scroller;\n    // if new items have been rendered in the area that is before current scroll position\n    // then this position will be updated silently in case of entire window scrollable\n    // so we need to remember the delta and to update scroll position manually right after it is changed silently\n    const inc = scrollBeforeRender >= viewport.paddings.backward.size ? 1 : -1;\n    const delta = inc * Math.abs(viewport.getScrollableSize() - state.sizeBeforeRender);\n    const positionToUpdate = scrollBeforeRender - delta;\n    if (delta && positionToUpdate > 0) {\n      window.positionToUpdate = positionToUpdate;\n      window.delta = delta;\n      scroller.logger.log(() => {\n        const token = delta < 0 ? 'reduced' : 'increased';\n        return [`next scroll position (if ${positionToUpdate}) should be ${token} by`, Math.abs(delta)];\n      });\n    }\n  }\n\n}\n","import { Scroller } from '../scroller';\r\nimport { Direction, Process, ProcessStatus } from '../interfaces/index';\r\n\r\nexport default class Adjust {\r\n\r\n  static MAX_SCROLL_ADJUSTMENTS_COUNT = 10;\r\n\r\n  static run(scroller: Scroller) {\r\n    scroller.state.preAdjustPosition = scroller.viewport.scrollPosition;\r\n\r\n    // padding-elements adjustments\r\n    const setPaddingsResult =\r\n      Adjust.setPaddings(scroller);\r\n\r\n    if (setPaddingsResult === false) {\r\n      scroller.callWorkflow({\r\n        process: Process.adjust,\r\n        status: ProcessStatus.error,\r\n        payload: { error: 'Can\\'t get visible item' }\r\n      });\r\n      return;\r\n    }\r\n\r\n    // scroll position adjustments\r\n    Adjust.fixScrollPosition(scroller, <number>setPaddingsResult);\r\n\r\n    scroller.callWorkflow({\r\n      process: Process.adjust,\r\n      status: ProcessStatus.done\r\n    });\r\n  }\r\n\r\n  static setPaddings(scroller: Scroller): boolean | number {\r\n    const { viewport, buffer, state: { fetch } } = scroller;\r\n    const firstItem = buffer.getFirstVisibleItem();\r\n    const lastItem = buffer.getLastVisibleItem();\r\n    if (!firstItem || !lastItem) {\r\n      return false;\r\n    }\r\n    const forwardPadding = viewport.paddings.forward;\r\n    const backwardPadding = viewport.paddings.backward;\r\n    const firstIndex = firstItem.$index;\r\n    const lastIndex = lastItem.$index;\r\n    const minIndex = isFinite(buffer.absMinIndex) ? buffer.absMinIndex : buffer.minIndex;\r\n    const maxIndex = isFinite(buffer.absMaxIndex) ? buffer.absMaxIndex : buffer.maxIndex;\r\n    const hasAverageItemSizeChanged = buffer.averageSize !== fetch.averageItemSize;\r\n    let index, bwdSize = 0, fwdSize = 0, bwdPaddingAverageSizeItemsCount = 0;\r\n\r\n    // new backward padding\r\n    for (index = minIndex; index < firstIndex; index++) {\r\n      const item = buffer.cache.get(index);\r\n      bwdSize += item ? item.size : buffer.cache.averageSize;\r\n      if (hasAverageItemSizeChanged) {\r\n        bwdPaddingAverageSizeItemsCount += !item ? 1 : 0;\r\n      }\r\n    }\r\n    if (hasAverageItemSizeChanged) {\r\n      for (index = firstIndex; index < <number>fetch.firstIndexBuffer; index++) {\r\n        bwdPaddingAverageSizeItemsCount += !buffer.cache.get(index) ? 1 : 0;\r\n      }\r\n    }\r\n\r\n    // new forward padding\r\n    for (index = lastIndex + 1; index <= maxIndex; index++) {\r\n      const item = buffer.cache.get(index);\r\n      fwdSize += item ? item.size : buffer.cache.averageSize;\r\n    }\r\n    const fwdPaddingDiff = forwardPadding.size - fwdSize;\r\n    const viewportSizeDiff = viewport.getSize() - viewport.getScrollableSize() + fwdPaddingDiff;\r\n    if (viewportSizeDiff > 0) {\r\n      fwdSize += viewportSizeDiff;\r\n      scroller.logger.log(`forward padding will be increased by ${viewportSizeDiff} to fill the viewport`);\r\n    }\r\n\r\n    forwardPadding.size = fwdSize;\r\n    backwardPadding.size = bwdSize;\r\n\r\n    scroller.logger.stat('after paddings adjustments');\r\n    return bwdPaddingAverageSizeItemsCount;\r\n  }\r\n\r\n  static fixScrollPosition(scroller: Scroller, bwdPaddingAverageSizeItemsCount: number) {\r\n    const { viewport, buffer, state, state: { fetch, fetch: { items, negativeSize } } } = scroller;\r\n\r\n    if (scroller.settings.windowViewport) {\r\n      const newPosition = viewport.scrollPosition;\r\n      const posDiff = state.preAdjustPosition - newPosition;\r\n      if (posDiff) {\r\n        const winState = state.scrollState.window;\r\n        if (newPosition === winState.positionToUpdate) {\r\n          winState.reset();\r\n          state.syntheticScroll.readyToReset = false;\r\n          scroller.logger.log(() => `process window scroll preventive: sum(${newPosition}, ${posDiff})`);\r\n          Adjust.setScroll(scroller, posDiff);\r\n          scroller.logger.stat('after scroll position adjustment (window)');\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    // if backward padding has been changed due to average item size change\r\n    const hasAverageItemSizeChanged = buffer.averageSize !== fetch.averageItemSize;\r\n    const bwdAverageItemsCountDiff = state.bwdPaddingAverageSizeItemsCount - bwdPaddingAverageSizeItemsCount;\r\n    const hasBwdParamsChanged = bwdPaddingAverageSizeItemsCount > 0 || bwdAverageItemsCountDiff > 0;\r\n    if (hasAverageItemSizeChanged && hasBwdParamsChanged) {\r\n      const _bwdPaddingAverageSize = bwdPaddingAverageSizeItemsCount * buffer.averageSize;\r\n      const bwdPaddingAverageSize = bwdPaddingAverageSizeItemsCount * fetch.averageItemSize;\r\n      const bwdPaddingAverageSizeDiff = _bwdPaddingAverageSize - bwdPaddingAverageSize;\r\n      const bwdAverageItemsSizeDiff = bwdAverageItemsCountDiff * fetch.averageItemSize;\r\n      const positionDiff = bwdPaddingAverageSizeDiff - bwdAverageItemsSizeDiff;\r\n      if (positionDiff) {\r\n        Adjust.setScroll(scroller, positionDiff);\r\n        scroller.logger.stat('after scroll position adjustment (average)');\r\n      }\r\n      state.bwdPaddingAverageSizeItemsCount = bwdPaddingAverageSizeItemsCount;\r\n    }\r\n\r\n    // if scrollable area size padding forward size have not been changed during this cycle\r\n    if (state.sizeBeforeRender === viewport.getScrollableSize() &&\r\n      viewport.paddings.forward.size === state.fwdPaddingBeforeRender) {\r\n      return;\r\n    }\r\n    // no negative area items\r\n    if (items[0].$index >= fetch.minIndex) {\r\n      return;\r\n    }\r\n\r\n    if (negativeSize > 0) {\r\n      Adjust.setScroll(scroller, negativeSize);\r\n    } else if (negativeSize < 0) {\r\n      viewport.paddings.forward.size -= negativeSize;\r\n      viewport.scrollPosition -= negativeSize;\r\n    }\r\n    scroller.logger.stat('after scroll position adjustment (negative)');\r\n  }\r\n\r\n  static setScroll(scroller: Scroller, delta: number) {\r\n    const { viewport } = scroller;\r\n    const forwardPadding = viewport.paddings[Direction.forward];\r\n    const oldPosition = viewport.scrollPosition;\r\n    const newPosition = Math.round(oldPosition + delta);\r\n    for (let i = 0; i < Adjust.MAX_SCROLL_ADJUSTMENTS_COUNT; i++) {\r\n      viewport.scrollPosition = newPosition;\r\n      const positionDiff = newPosition - viewport.scrollPosition;\r\n      if (positionDiff > 0) {\r\n        forwardPadding.size += positionDiff;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n","import { Scroller } from '../scroller';\r\nimport { Direction, Process, ProcessStatus } from '../interfaces/index';\r\n\r\nexport default class Clip {\r\n\r\n  static run(scroller: Scroller) {\r\n    Clip.prepareClip(scroller);\r\n\r\n    if (scroller.state.clip) {\r\n      Clip.doClip(scroller);\r\n    }\r\n\r\n    scroller.callWorkflow({\r\n      process: Process.clip,\r\n      status: ProcessStatus.next\r\n    });\r\n  }\r\n\r\n  static prepareClip(scroller: Scroller) {\r\n    const { buffer, state, state: { fetch, fetch: { direction } } } = scroller;\r\n    if (!buffer.size) {\r\n      return;\r\n    }\r\n    if (state.isInitialWorkflowCycle && !state.scrollState.scroll) {\r\n      scroller.logger.log(`skipping clip [initial cycle, no scroll]`);\r\n      return;\r\n    }\r\n    const firstIndex = <number>fetch.firstIndexBuffer;\r\n    const lastIndex = <number>fetch.lastIndexBuffer;\r\n    scroller.logger.log(() =>\r\n      `looking for ${direction ? 'anti-' + direction + ' ' : ''}items ` +\r\n      `that are out of [${firstIndex}..${lastIndex}] range`);\r\n    if (!direction || direction === Direction.forward) {\r\n      if (firstIndex - 1 >= buffer.absMinIndex) {\r\n        Clip.prepareClipByDirection(scroller, Direction.forward, firstIndex);\r\n      }\r\n    }\r\n    if (!direction || direction === Direction.backward) {\r\n      if (lastIndex + 1 <= buffer.absMaxIndex) {\r\n        Clip.prepareClipByDirection(scroller, Direction.backward, lastIndex);\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  static prepareClipByDirection(scroller: Scroller, direction: Direction, edgeIndex: number) {\r\n    const forward = direction === Direction.forward;\r\n    scroller.buffer.items.forEach(item => {\r\n      if (\r\n        (forward && item.$index < edgeIndex) ||\r\n        (!forward && item.$index > edgeIndex)\r\n      ) {\r\n        item.toRemove = true;\r\n        item.removeDirection = direction;\r\n        scroller.state.clip = true;\r\n      }\r\n    });\r\n  }\r\n\r\n  static doClip(scroller: Scroller) {\r\n    const { buffer, viewport: { paddings }, logger } = scroller;\r\n    const clipped: Array<number> = [];\r\n    const size = { backward: 0, forward: 0 };\r\n    scroller.state.clipCall++;\r\n    logger.stat(`before clip (${scroller.state.clipCall})`);\r\n    buffer.items = buffer.items.filter(item => {\r\n      if (item.toRemove) {\r\n        size[item.removeDirection] += item.size;\r\n        item.hide();\r\n        clipped.push(item.$index);\r\n        return false;\r\n      }\r\n      return true;\r\n    });\r\n    if (size.backward) {\r\n      paddings.forward.size += size.backward;\r\n    }\r\n    if (size.forward) {\r\n      paddings.backward.size += size.forward;\r\n    }\r\n    logger.log(() => [\r\n      `clipped ${clipped.length} items` +\r\n      (size.backward ? `, +${size.backward} fwd px,` : '') +\r\n      (size.forward ? `, +${size.forward} bwd px,` : ''),\r\n      `range: [${clipped[0]}..${clipped[clipped.length - 1]}]`\r\n    ]);\r\n    logger.stat('after clip');\r\n  }\r\n\r\n}\r\n","import { Scroller } from '../scroller';\nimport { Process, ProcessStatus, ProcessRun, Direction } from '../interfaces/index';\nimport { itemAdapterEmpty } from '../classes/adapter';\n\nexport default class End {\n\n  static run(scroller: Scroller, error?: any) {\n    // finalize current workflow loop\n    End.endWorkflowLoop(scroller);\n\n    // set out params, accessible via Adapter\n    End.calculateParams(scroller);\n\n    // what next? done?\n    const next = End.getNext(scroller, error);\n\n    // need to apply Buffer.items changes if clip\n    if (scroller.state.clip) {\n      scroller.runChangeDetector();\n    }\n\n    // stub method call\n    scroller.finalize();\n\n    // continue the Workflow synchronously; current cycle could be finilized immediately\n    scroller.callWorkflow({\n      process: Process.end,\n      status: next ? ProcessStatus.next : ProcessStatus.done,\n      payload: next || { empty: true }\n    });\n\n    // if the Workflow isn't finilized, it may freeze for no more than settings.throttle ms\n    if (scroller.state.workflowPending && !scroller.state.loopPending) {\n      // continue the Workflow asynchronously\n      End.continueWorkflowByTimer(scroller);\n    }\n  }\n\n  static endWorkflowLoop(scroller: Scroller) {\n    const { state } = scroller;\n    state.endLoop();\n    state.lastPosition = scroller.viewport.scrollPosition;\n    scroller.purgeInnerLoopSubscriptions();\n  }\n\n  static calculateParams(scroller: Scroller) {\n    const { items } = scroller.buffer;\n\n    // first visible item\n    if (scroller.state.firstVisibleWanted) {\n      const viewportBackwardEdge = scroller.viewport.getEdge(Direction.backward);\n      const firstItem = items.find(item =>\n        scroller.viewport.getElementEdge(item.element, Direction.forward) > viewportBackwardEdge\n      );\n      scroller.state.firstVisibleItem = firstItem ? {\n        $index: firstItem.$index,\n        data: firstItem.data,\n        element: firstItem.element\n      } : itemAdapterEmpty;\n    }\n\n    // last visible item\n    if (scroller.state.lastVisibleWanted) {\n      const viewportForwardEdge = scroller.viewport.getEdge(Direction.forward);\n      let lastItem = null;\n      for (let i = items.length - 1; i >= 0; i--) {\n        const edge = scroller.viewport.getElementEdge(items[i].element, Direction.backward);\n        if (edge < viewportForwardEdge) {\n          lastItem = items[i];\n          break;\n        }\n      }\n      scroller.state.lastVisibleItem = lastItem ? {\n        $index: lastItem.$index,\n        data: lastItem.data,\n        element: lastItem.element\n      } : itemAdapterEmpty;\n    }\n  }\n\n  static getNext(scroller: Scroller, error?: any): ProcessRun | null {\n    const { state: { fetch, scrollState } } = scroller;\n    let next: ProcessRun | null = null;\n    if (!error) {\n      if (fetch.hasNewItems) {\n        next = { scroll: false };\n      } else if (fetch.hasAnotherPack) {\n        next = { scroll: false };\n      }\n      if (scrollState.keepScroll) {\n        next = { scroll: true, keepScroll: true };\n      }\n    }\n    return next;\n  }\n\n  static continueWorkflowByTimer(scroller: Scroller) {\n    const { state, state: { workflowCycleCount, innerLoopCount } } = scroller;\n    scroller.logger.log(() => `setting Workflow timer (${workflowCycleCount}-${innerLoopCount})`);\n    state.scrollState.workflowTimer = <any>setTimeout(() => {\n      // if the WF isn't finilized while the old sub-cycle is done and there's no new sub-cycle\n      if (state.workflowPending && !state.loopPending && innerLoopCount === state.innerLoopCount) {\n        scroller.callWorkflow({\n          process: Process.end,\n          status: ProcessStatus.next,\n          payload: { scroll: true, byTimer: true }\n        });\n      }\n    }, scroller.settings.throttle);\n  }\n\n}\n","import { Subscription, BehaviorSubject } from 'rxjs';\n\nimport { UiScrollComponent } from '../ui-scroll.component';\nimport { Scroller } from './scroller';\nimport { Process, ProcessStatus as Status, ProcessSubject } from './interfaces/index';\nimport { Init, Scroll, Reload, Start, PreFetch, Fetch, PostFetch, Render, Clip, Adjust, End } from './processes/index';\n\nexport class Workflow {\n\n  scroller: Scroller;\n  process$: BehaviorSubject<ProcessSubject>;\n  cyclesDone: number;\n\n  readonly context: UiScrollComponent;\n  readonly onScrollHandler: EventListener;\n  private itemsSubscription: Subscription;\n  private workflowSubscription: Subscription;\n  private scrollEventOptions: any;\n\n  constructor(context: UiScrollComponent) {\n    this.context = context;\n    this.scroller = new Scroller(this.context, this.callWorkflow.bind(this));\n    this.process$ = new BehaviorSubject(<ProcessSubject>{\n      process: Process.init,\n      status: Status.start\n    });\n    this.cyclesDone = 0;\n    this.onScrollHandler = event => Scroll.run(this.scroller, { event });\n\n    if (this.scroller.settings.initializeDelay) {\n      setTimeout(() => this.init(), this.scroller.settings.initializeDelay);\n    } else {\n      this.init();\n    }\n  }\n\n  init() {\n    this.scroller.init();\n    this.scroller.logger.stat('initialization');\n    this.initListeners();\n  }\n\n  initListeners() {\n    const scroller = this.scroller;\n    scroller.logger.log(() => `uiScroll Workflow listeners are being initialized`);\n    this.itemsSubscription = scroller.buffer.$items.subscribe(items => this.context.items = items);\n    this.workflowSubscription = this.process$.subscribe(this.process.bind(this));\n    this.initScrollEventListener();\n  }\n\n  initScrollEventListener() {\n    let passiveSupported = false;\n    try {\n      window.addEventListener(\n        'test', <EventListenerOrEventListenerObject>{}, Object.defineProperty({}, 'passive', {\n          get: () => passiveSupported = true\n        })\n      );\n    } catch (err) {\n    }\n    this.scrollEventOptions = passiveSupported ? { passive: false } : false;\n    this.scroller.viewport.scrollEventElement.addEventListener(\n      'scroll', this.onScrollHandler, this.scrollEventOptions\n    );\n  }\n\n  detachScrollEventListener() {\n    this.scroller.viewport.scrollEventElement.removeEventListener(\n      'scroll', this.onScrollHandler, this.scrollEventOptions\n    );\n  }\n\n  process(data: ProcessSubject) {\n    const scroller = this.scroller;\n    const { status, payload } = data;\n    this.scroller.logger.logProcess(data);\n    if (status === Status.error) {\n      End.run(scroller, payload);\n      return;\n    }\n    switch (data.process) {\n      case Process.init:\n        if (status === Status.start) {\n          Init.run(scroller);\n        }\n        if (status === Status.next) {\n          Start.run(scroller, payload);\n        }\n        break;\n      case Process.reload:\n        if (status === Status.start) {\n          Reload.run(scroller, payload);\n        }\n        if (status === Status.next) {\n          Init.run(scroller);\n        }\n        break;\n      case Process.scroll:\n        if (status === Status.next) {\n          if (!(payload && payload.keepScroll)) {\n            Init.run(scroller, payload);\n          } else {\n            Start.run(scroller, payload);\n          }\n        }\n        break;\n      case Process.start:\n        if (status === Status.next) {\n          PreFetch.run(scroller);\n        }\n        break;\n      case Process.preFetch:\n        if (status === Status.done) {\n          End.run(scroller);\n        }\n        if (status === Status.next) {\n          Fetch.run(scroller);\n        }\n        break;\n      case Process.fetch:\n        if (status === Status.next) {\n          PostFetch.run(scroller);\n        }\n        break;\n      case Process.postFetch:\n        if (status === Status.next) {\n          Render.run(scroller);\n        }\n        if (status === Status.done) {\n          End.run(scroller);\n        }\n        break;\n      case Process.render:\n        if (status === Status.next) {\n          if (scroller.settings.infinite) {\n            Adjust.run(scroller);\n          } else {\n            Clip.run(scroller);\n          }\n        }\n        break;\n      case Process.clip:\n        if (status === Status.next) {\n          Adjust.run(scroller);\n        }\n        break;\n      case Process.adjust:\n        if (status === Status.done) {\n          End.run(scroller);\n        }\n        break;\n      case Process.end:\n        if (status === Status.next) {\n          if (payload && payload.keepScroll) {\n            Scroll.run(scroller);\n          } else {\n            Start.run(scroller, payload);\n          }\n        }\n        if (status === Status.done) {\n          this.done();\n        }\n        break;\n    }\n  }\n\n  callWorkflow(processSubject: ProcessSubject) {\n    this.process$.next(processSubject);\n  }\n\n  done() {\n    const { state } = this.scroller;\n    this.cyclesDone++;\n    state.workflowCycleCount = this.cyclesDone + 1;\n    state.isInitialWorkflowCycle = false;\n    state.workflowPending = false;\n    if (state.scrollState.scrollTimer === null) {\n      state.isLoading = false;\n    }\n    this.finalize();\n  }\n\n  dispose() {\n    this.detachScrollEventListener();\n    this.process$.complete();\n    this.workflowSubscription.unsubscribe();\n    this.itemsSubscription.unsubscribe();\n    this.scroller.dispose();\n  }\n\n  finalize() {\n  }\n\n}\n","import {\n  Component, OnInit, OnDestroy,\n  TemplateRef, ElementRef,\n  ChangeDetectionStrategy, ChangeDetectorRef\n} from '@angular/core';\n\nimport { Workflow } from './component/workflow';\nimport { Datasource as IDatasource } from './component/interfaces/index';\nimport { Datasource } from './component/classes/datasource';\nimport { Item } from './component/classes/item';\n\n@Component({\n  selector: '[ui-scroll]',\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  template: `<div data-padding-backward></div><div\n  *ngFor=\"let item of items\"\n  [attr.data-sid]=\"item.nodeId\"\n  [style.position]=\"item.invisible ? 'fixed' : null\"\n  [style.left]=\"item.invisible ? '-99999px' : null\"\n><ng-template\n  [ngTemplateOutlet]=\"template\"\n  [ngTemplateOutletContext]=\"{\n    $implicit: item.data,\n    index: item.$index,\n    odd: item.$index % 2,\n    even: !(item.$index % 2)\n }\"\n></ng-template></div><div data-padding-forward></div>`\n})\nexport class UiScrollComponent implements OnInit, OnDestroy {\n\n  // come from the directive\n  public version: string;\n  public template: TemplateRef<any>;\n  public datasource: IDatasource | Datasource;\n\n  // use in the template\n  public items: Array<Item>;\n\n  // Component-Workflow integration\n  public workflow: Workflow;\n\n  constructor(\n    public changeDetector: ChangeDetectorRef,\n    public elementRef: ElementRef\n  ) {\n  }\n\n  ngOnInit() {\n    this.workflow = new Workflow(this);\n  }\n\n  ngOnDestroy() {\n    this.workflow.dispose();\n  }\n}\n","import { Directive, Input, TemplateRef, ViewContainerRef, ComponentFactoryResolver, OnInit } from '@angular/core';\n\nimport version from './ui-scroll.version';\nimport { UiScrollComponent } from './ui-scroll.component';\nimport { Datasource } from './component/interfaces/datasource';\n\n@Directive({ selector: '[uiScroll][uiScrollOf]' })\nexport class UiScrollDirective implements OnInit {\n  private version: string;\n  private datasource: Datasource;\n\n  constructor(\n    private templateRef: TemplateRef<any>,\n    private viewContainer: ViewContainerRef,\n    private resolver: ComponentFactoryResolver\n  ) {\n  }\n\n  @Input() set uiScrollOf(datasource: Datasource) {\n    this.datasource = datasource;\n  }\n\n  ngOnInit() {\n    const templateView = this.templateRef.createEmbeddedView({});\n    const compFactory = this.resolver.resolveComponentFactory(UiScrollComponent);\n    const componentRef = this.viewContainer.createComponent(\n      compFactory, undefined, this.viewContainer.injector, [templateView.rootNodes]\n    );\n    componentRef.instance.datasource = this.datasource;\n    componentRef.instance.template = this.templateRef;\n    componentRef.instance.version = version;\n  }\n}\n","export default '1.0.1';\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { UiScrollComponent } from './ui-scroll.component';\nimport { UiScrollDirective } from './ui-scroll.directive';\n\n@NgModule({\n  declarations: [\n    UiScrollComponent,\n    UiScrollDirective\n  ],\n  imports: [CommonModule],\n  entryComponents: [UiScrollComponent],\n  exports: [UiScrollDirective],\n  providers: []\n})\nexport class UiScrollModule { }\n"]}