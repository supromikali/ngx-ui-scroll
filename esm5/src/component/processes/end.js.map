{"version":3,"file":"end.js","sourceRoot":"","sources":["../../../../src/component/processes/end.ts"],"names":[],"mappings":";;;;AACA,OAAO,EAAE,OAAO,EAAE,aAAa,EAAc,SAAS,EAAE,MAAM,qBAAqB,CAAC;AACpF,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AAEtD;IAAA;IA2GA,CAAC;;;;;;IAzGQ,OAAG;;;;;IAAV,UAAW,QAAkB,EAAE,KAAW;QACxC,iCAAiC;QACjC,GAAG,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;QAE9B,yCAAyC;QACzC,GAAG,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;;;YAGxB,IAAI,GAAG,GAAG,CAAC,OAAO,CAAC,QAAQ,EAAE,KAAK,CAAC;QAEzC,6CAA6C;QAC7C,IAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE;YACvB,QAAQ,CAAC,iBAAiB,EAAE,CAAC;SAC9B;QAED,mBAAmB;QACnB,QAAQ,CAAC,QAAQ,EAAE,CAAC;QAEpB,oFAAoF;QACpF,QAAQ,CAAC,YAAY,CAAC;YACpB,OAAO,EAAE,OAAO,CAAC,GAAG;YACpB,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,aAAa,CAAC,IAAI;YACtD,OAAO,EAAE,IAAI,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE;SACjC,CAAC,CAAC;QAEH,uFAAuF;QACvF,IAAI,QAAQ,CAAC,KAAK,CAAC,eAAe,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,WAAW,EAAE;YACjE,uCAAuC;YACvC,GAAG,CAAC,uBAAuB,CAAC,QAAQ,CAAC,CAAC;SACvC;IACH,CAAC;;;;;IAEM,mBAAe;;;;IAAtB,UAAuB,QAAkB;QAC/B,IAAA,sBAAK;QACb,KAAK,CAAC,OAAO,EAAE,CAAC;QAChB,KAAK,CAAC,YAAY,GAAG,QAAQ,CAAC,QAAQ,CAAC,cAAc,CAAC;QACtD,QAAQ,CAAC,2BAA2B,EAAE,CAAC;IACzC,CAAC;;;;;IAEM,mBAAe;;;;IAAtB,UAAuB,QAAkB;QAC/B,IAAA,6BAAK;QAEb,qBAAqB;QACrB,IAAI,QAAQ,CAAC,KAAK,CAAC,kBAAkB,EAAE;;gBAC/B,sBAAoB,GAAG,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,SAAS,CAAC,QAAQ,CAAC;;gBACpE,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,UAAA,IAAI;gBAC/B,OAAA,QAAQ,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,CAAC,OAAO,CAAC,GAAG,sBAAoB;YAAxF,CAAwF,CACzF;YACD,QAAQ,CAAC,KAAK,CAAC,gBAAgB,GAAG,SAAS,CAAC,CAAC,CAAC;gBAC5C,MAAM,EAAE,SAAS,CAAC,MAAM;gBACxB,IAAI,EAAE,SAAS,CAAC,IAAI;gBACpB,OAAO,EAAE,SAAS,CAAC,OAAO;aAC3B,CAAC,CAAC,CAAC,gBAAgB,CAAC;SACtB;QAED,oBAAoB;QACpB,IAAI,QAAQ,CAAC,KAAK,CAAC,iBAAiB,EAAE;;gBAC9B,mBAAmB,GAAG,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC;;gBACpE,QAAQ,GAAG,IAAI;YACnB,KAAK,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;;oBACpC,IAAI,GAAG,QAAQ,CAAC,QAAQ,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,SAAS,CAAC,QAAQ,CAAC;gBACnF,IAAI,IAAI,GAAG,mBAAmB,EAAE;oBAC9B,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;oBACpB,MAAM;iBACP;aACF;YACD,QAAQ,CAAC,KAAK,CAAC,eAAe,GAAG,QAAQ,CAAC,CAAC,CAAC;gBAC1C,MAAM,EAAE,QAAQ,CAAC,MAAM;gBACvB,IAAI,EAAE,QAAQ,CAAC,IAAI;gBACnB,OAAO,EAAE,QAAQ,CAAC,OAAO;aAC1B,CAAC,CAAC,CAAC,gBAAgB,CAAC;SACtB;IACH,CAAC;;;;;;IAEM,WAAO;;;;;IAAd,UAAe,QAAkB,EAAE,KAAW;QACpC,IAAA,mBAA6B,EAApB,gBAAK,EAAE,4BAAa;;YACjC,IAAI,GAAsB,IAAI;QAClC,IAAI,CAAC,KAAK,EAAE;YACV,IAAI,KAAK,CAAC,WAAW,EAAE;gBACrB,IAAI,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC;aAC1B;iBAAM,IAAI,KAAK,CAAC,cAAc,EAAE;gBAC/B,IAAI,GAAG,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC;aAC1B;YACD,IAAI,WAAW,CAAC,UAAU,EAAE;gBAC1B,IAAI,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC;aAC3C;SACF;QACD,OAAO,IAAI,CAAC;IACd,CAAC;;;;;IAEM,2BAAuB;;;;IAA9B,UAA+B,QAAkB;QACvC,IAAA,sBAAK,EAAE,mBAA6C,EAApC,0CAAkB,EAAE,kCAAgB;QAC5D,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,cAAM,OAAA,6BAA2B,kBAAkB,SAAI,cAAc,MAAG,EAAlE,CAAkE,CAAC,CAAC;QAC9F,KAAK,CAAC,WAAW,CAAC,aAAa,GAAG,mBAAK,UAAU,CAAC;YAChD,yFAAyF;YACzF,IAAI,KAAK,CAAC,eAAe,IAAI,CAAC,KAAK,CAAC,WAAW,IAAI,cAAc,KAAK,KAAK,CAAC,cAAc,EAAE;gBAC1F,QAAQ,CAAC,YAAY,CAAC;oBACpB,OAAO,EAAE,OAAO,CAAC,GAAG;oBACpB,MAAM,EAAE,aAAa,CAAC,IAAI;oBAC1B,OAAO,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE;iBACzC,CAAC,CAAC;aACJ;QACH,CAAC,EAAE,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAA,CAAC;IACjC,CAAC;IAEH,UAAC;AAAD,CAAC,AA3GD,IA2GC","sourcesContent":["import { Scroller } from '../scroller';\nimport { Process, ProcessStatus, ProcessRun, Direction } from '../interfaces/index';\nimport { itemAdapterEmpty } from '../classes/adapter';\n\nexport default class End {\n\n  static run(scroller: Scroller, error?: any) {\n    // finalize current workflow loop\n    End.endWorkflowLoop(scroller);\n\n    // set out params, accessible via Adapter\n    End.calculateParams(scroller);\n\n    // what next? done?\n    const next = End.getNext(scroller, error);\n\n    // need to apply Buffer.items changes if clip\n    if (scroller.state.clip) {\n      scroller.runChangeDetector();\n    }\n\n    // stub method call\n    scroller.finalize();\n\n    // continue the Workflow synchronously; current cycle could be finilized immediately\n    scroller.callWorkflow({\n      process: Process.end,\n      status: next ? ProcessStatus.next : ProcessStatus.done,\n      payload: next || { empty: true }\n    });\n\n    // if the Workflow isn't finilized, it may freeze for no more than settings.throttle ms\n    if (scroller.state.workflowPending && !scroller.state.loopPending) {\n      // continue the Workflow asynchronously\n      End.continueWorkflowByTimer(scroller);\n    }\n  }\n\n  static endWorkflowLoop(scroller: Scroller) {\n    const { state } = scroller;\n    state.endLoop();\n    state.lastPosition = scroller.viewport.scrollPosition;\n    scroller.purgeInnerLoopSubscriptions();\n  }\n\n  static calculateParams(scroller: Scroller) {\n    const { items } = scroller.buffer;\n\n    // first visible item\n    if (scroller.state.firstVisibleWanted) {\n      const viewportBackwardEdge = scroller.viewport.getEdge(Direction.backward);\n      const firstItem = items.find(item =>\n        scroller.viewport.getElementEdge(item.element, Direction.forward) > viewportBackwardEdge\n      );\n      scroller.state.firstVisibleItem = firstItem ? {\n        $index: firstItem.$index,\n        data: firstItem.data,\n        element: firstItem.element\n      } : itemAdapterEmpty;\n    }\n\n    // last visible item\n    if (scroller.state.lastVisibleWanted) {\n      const viewportForwardEdge = scroller.viewport.getEdge(Direction.forward);\n      let lastItem = null;\n      for (let i = items.length - 1; i >= 0; i--) {\n        const edge = scroller.viewport.getElementEdge(items[i].element, Direction.backward);\n        if (edge < viewportForwardEdge) {\n          lastItem = items[i];\n          break;\n        }\n      }\n      scroller.state.lastVisibleItem = lastItem ? {\n        $index: lastItem.$index,\n        data: lastItem.data,\n        element: lastItem.element\n      } : itemAdapterEmpty;\n    }\n  }\n\n  static getNext(scroller: Scroller, error?: any): ProcessRun | null {\n    const { state: { fetch, scrollState } } = scroller;\n    let next: ProcessRun | null = null;\n    if (!error) {\n      if (fetch.hasNewItems) {\n        next = { scroll: false };\n      } else if (fetch.hasAnotherPack) {\n        next = { scroll: false };\n      }\n      if (scrollState.keepScroll) {\n        next = { scroll: true, keepScroll: true };\n      }\n    }\n    return next;\n  }\n\n  static continueWorkflowByTimer(scroller: Scroller) {\n    const { state, state: { workflowCycleCount, innerLoopCount } } = scroller;\n    scroller.logger.log(() => `setting Workflow timer (${workflowCycleCount}-${innerLoopCount})`);\n    state.scrollState.workflowTimer = <any>setTimeout(() => {\n      // if the WF isn't finilized while the old sub-cycle is done and there's no new sub-cycle\n      if (state.workflowPending && !state.loopPending && innerLoopCount === state.innerLoopCount) {\n        scroller.callWorkflow({\n          process: Process.end,\n          status: ProcessStatus.next,\n          payload: { scroll: true, byTimer: true }\n        });\n      }\n    }, scroller.settings.throttle);\n  }\n\n}\n"]}