{"version":3,"file":"render.js","sourceRoot":"","sources":["../../../../src/component/processes/render.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scroller } from '../scroller';\nimport { Process, ProcessStatus } from '../interfaces/index';\n\nexport default class Render {\n\n  static run(scroller: Scroller) {\n    scroller.logger.stat('before new items render');\n    scroller.innerLoopSubscriptions.push(\n      scroller.bindData().subscribe(() => {\n        if (Render.processElements(scroller)) {\n          scroller.callWorkflow({\n            process: Process.render,\n            status: ProcessStatus.next\n          });\n        } else {\n          scroller.callWorkflow({\n            process: Process.render,\n            status: ProcessStatus.error,\n            payload: { error: 'Can\\'t associate item with element' }\n          });\n        }\n      })\n    );\n  }\n\n  static processElements(scroller: Scroller) {\n    const { state, state: { fetch, fetch: { items } }, viewport, buffer } = scroller;\n    const itemsLength = items.length;\n    const scrollBeforeRender = scroller.settings.windowViewport ? scroller.viewport.scrollPosition : 0;\n    state.sizeBeforeRender = viewport.getScrollableSize();\n    state.fwdPaddingBeforeRender = viewport.paddings.forward.size;\n    for (let j = 0; j < itemsLength; j++) {\n      const item = items[j];\n      const element = viewport.element.querySelector(`[data-sid=\"${item.nodeId}\"]`);\n      if (!element) {\n        return false;\n      }\n      item.element = <HTMLElement>element;\n      item.element.style.left = '';\n      item.element.style.position = '';\n      item.invisible = false;\n      item.setSize();\n      buffer.cache.add(item);\n      if (item.$index < fetch.minIndex) {\n        fetch.negativeSize += item.size;\n      }\n    }\n    buffer.checkAverageSize();\n    if (scroller.settings.windowViewport && fetch.isPrepend) {\n      Render.processWindowScrollBackJump(scroller, scrollBeforeRender);\n    }\n    scroller.logger.stat('after new items render');\n    return true;\n  }\n\n  static processWindowScrollBackJump(scroller: Scroller, scrollBeforeRender: number) {\n    const { state, state: { scrollState: { window } }, viewport } = scroller;\n    // if new items have been rendered in the area that is before current scroll position\n    // then this position will be updated silently in case of entire window scrollable\n    // so we need to remember the delta and to update scroll position manually right after it is changed silently\n    const inc = scrollBeforeRender >= viewport.paddings.backward.size ? 1 : -1;\n    const delta = inc * Math.abs(viewport.getScrollableSize() - state.sizeBeforeRender);\n    const positionToUpdate = scrollBeforeRender - delta;\n    if (delta && positionToUpdate > 0) {\n      window.positionToUpdate = positionToUpdate;\n      window.delta = delta;\n      scroller.logger.log(() => {\n        const token = delta < 0 ? 'reduced' : 'increased';\n        return [`next scroll position (if ${positionToUpdate}) should be ${token} by`, Math.abs(delta)];\n      });\n    }\n  }\n\n}\n"]}