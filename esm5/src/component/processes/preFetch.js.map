{"version":3,"file":"preFetch.js","sourceRoot":"","sources":["../../../../src/component/processes/preFetch.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scroller } from '../scroller';\nimport { Process, ProcessStatus, Direction } from '../interfaces/index';\n\nexport default class PreFetch {\n\n  static run(scroller: Scroller) {\n    const { fetch } = scroller.state;\n    scroller.state.preFetchPosition = scroller.viewport.scrollPosition;\n    fetch.minIndex = scroller.buffer.minIndex;\n    fetch.averageItemSize = scroller.buffer.averageSize || 0;\n\n    // calculate size before start index\n    PreFetch.setStartDelta(scroller);\n\n    // set first and last indexes to fetch\n    PreFetch.setFetchIndexes(scroller);\n\n    // skip indexes that are in buffer\n    PreFetch.skipBufferedItems(scroller);\n\n    // add indexes if there are too few items to fetch (clip padding)\n    PreFetch.checkFetchPackSize(scroller);\n\n    // set fetch direction\n    PreFetch.setFetchDirection(scroller);\n\n    if (fetch.shouldFetch) {\n      scroller.logger.log(() => `going to fetch ${fetch.count} items started from index ${fetch.index}`);\n    }\n\n    scroller.callWorkflow({\n      process: Process.preFetch,\n      status: scroller.state.fetch.shouldFetch ? ProcessStatus.next : ProcessStatus.done\n    });\n  }\n\n  static setStartDelta(scroller: Scroller) {\n    const { buffer, viewport } = scroller;\n    viewport.startDelta = 0;\n    if (!buffer.hasItemSize) {\n      return;\n    }\n    const minIndex = isFinite(buffer.absMinIndex) ? buffer.absMinIndex : buffer.minIndex;\n    for (let index = minIndex; index < scroller.state.startIndex; index++) {\n      const item = buffer.cache.get(index);\n      viewport.startDelta += item ? item.size : buffer.averageSize;\n    }\n    if (scroller.settings.windowViewport) {\n      viewport.startDelta += viewport.getOffset();\n    }\n    scroller.logger.log(() => `start delta is ${viewport.startDelta}`);\n  }\n\n  static setFetchIndexes(scroller: Scroller) {\n    const { state, viewport } = scroller;\n    const paddingDelta = viewport.getBufferPadding();\n    const relativePosition = state.preFetchPosition - viewport.startDelta;\n    const startPosition = relativePosition - paddingDelta;\n    const endPosition = relativePosition + viewport.getSize() + paddingDelta;\n    const firstIndexPosition =\n      PreFetch.setFirstIndexBuffer(scroller, startPosition);\n    PreFetch.setLastIndexBuffer(scroller, firstIndexPosition, endPosition);\n    scroller.logger.fetch();\n  }\n\n  static setFirstIndexBuffer(scroller: Scroller, startPosition: number): number {\n    const { state, buffer, state: { fetch } } = scroller;\n    let firstIndex = state.startIndex;\n    let firstIndexPosition = 0;\n    if (scroller.state.isInitialLoop) {\n      scroller.logger.log(`skipping fetch backward direction [initial loop]`);\n    } else {\n      const inc = startPosition < 0 ? -1 : 1;\n      let position = firstIndexPosition;\n      let index = firstIndex;\n      while (1) {\n        index += inc;\n        if (index < buffer.absMinIndex) {\n          break;\n        }\n        position += inc * buffer.getSizeByIndex(index);\n        if (inc < 0) {\n          firstIndex = index;\n          firstIndexPosition = position;\n          if (position <= startPosition) {\n            break;\n          }\n        } else {\n          if (position > startPosition) {\n            break;\n          }\n          firstIndex = index;\n          firstIndexPosition = position;\n        }\n      }\n    }\n    fetch.firstIndex = fetch.firstIndexBuffer = Math.max(firstIndex, buffer.absMinIndex);\n    return firstIndexPosition;\n  }\n\n  static setLastIndexBuffer(scroller: Scroller, startPosition: number, endPosition: number) {\n    const { state, buffer, settings } = scroller;\n    let lastIndex;\n    if (!buffer.hasItemSize) {\n      // just to fetch forward bufferSize items if neither averageItemSize nor itemSize are present\n      lastIndex = state.startIndex + settings.bufferSize - 1;\n      scroller.logger.log(`forcing fetch forward direction [no item size]`);\n    } else {\n      let index = <number>state.fetch.firstIndexBuffer;\n      let position = startPosition;\n      let lastIndexPosition;\n      lastIndex = index;\n      while (1) {\n        lastIndex = index;\n        index++;\n        position += buffer.getSizeByIndex(index);\n        lastIndexPosition = position;\n        if (position >= endPosition) {\n          break;\n        }\n        if (index > buffer.absMaxIndex) {\n          break;\n        }\n      }\n    }\n    state.fetch.lastIndex = state.fetch.lastIndexBuffer = Math.min(lastIndex, buffer.absMaxIndex);\n  }\n\n  static skipBufferedItems(scroller: Scroller) {\n    const buffer = scroller.buffer;\n    if (!buffer.size) {\n      return;\n    }\n    const { fetch } = scroller.state;\n    const firstIndex = <number>fetch.firstIndex;\n    const lastIndex = <number>fetch.lastIndex;\n    const packs: Array<Array<number>> = [[]];\n    let p = 0;\n    for (let i = firstIndex; i <= lastIndex; i++) {\n      if (!buffer.get(i)) {\n        packs[p].push(i);\n      } else if (packs[p].length) {\n        packs[++p] = [];\n      }\n    }\n    let pack = packs[0];\n    if (packs[0].length && packs[1] && packs[1].length) {\n      fetch.hasAnotherPack = true;\n      // todo: need to look for biggest pack in visible area\n      // todo: or think about merging two requests in a single Fetch process\n      if (packs[1].length >= packs[0].length) {\n        pack = packs[1];\n      }\n    }\n    fetch.firstIndex = Math.max(pack[0], buffer.absMinIndex);\n    fetch.lastIndex = Math.min(pack[pack.length - 1], buffer.absMaxIndex);\n    if (fetch.firstIndex !== firstIndex || fetch.lastIndex !== lastIndex) {\n      scroller.logger.fetch('after Buffer flushing');\n    }\n  }\n\n  static checkFetchPackSize(scroller: Scroller) {\n    const { buffer, state: { fetch } } = scroller;\n    if (!fetch.shouldFetch) {\n      return;\n    }\n    const firstIndex = <number>fetch.firstIndex;\n    const lastIndex = <number>fetch.lastIndex;\n    const diff = scroller.settings.bufferSize - (lastIndex - firstIndex + 1);\n    if (diff <= 0) {\n      return;\n    }\n    if (!buffer.size || lastIndex > buffer.items[0].$index) { // forward\n      const newLastIndex = Math.min(lastIndex + diff, buffer.absMaxIndex);\n      if (newLastIndex > lastIndex) {\n        fetch.lastIndex = fetch.lastIndexBuffer = newLastIndex;\n      }\n    } else {\n      const newFirstIndex = Math.max(firstIndex - diff, buffer.absMinIndex);\n      if (newFirstIndex < firstIndex) {\n        fetch.firstIndex = fetch.firstIndexBuffer = newFirstIndex;\n      }\n    }\n    if (fetch.firstIndex !== firstIndex || fetch.lastIndex !== lastIndex) {\n      scroller.logger.fetch('after bufferSize adjustment');\n      PreFetch.skipBufferedItems(scroller);\n    }\n  }\n\n  static setFetchDirection(scroller: Scroller) {\n    const { buffer, state: { fetch } } = scroller;\n    if (fetch.lastIndex) {\n      let direction = Direction.forward;\n      if (buffer.size) {\n        direction = fetch.lastIndex < buffer.items[0].$index ? Direction.backward : Direction.forward;\n      }\n      fetch.direction = direction;\n      scroller.logger.log(() => `fetch direction is \"${direction}\"`);\n    }\n  }\n\n}\n"]}